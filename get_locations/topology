#!/usr/bin/perl
#
# Copyright (c) 2010-2017 Hewlett Packard Enterprise Development LP.  All Rights Reserved.
#
# Display topology info for an SGI Ultraviolet (UV) system.
#
# Usage is at the bottom of the file.
#
# NVIDIA device numbers:
# https://pci-ids.ucw.cz/read/PC/10de

use strict;
use Getopt::Long;
use POSIX;
use Text::ParseWords; #quotewords
# these 3 are for nilink_reroute_event
use File::Compare;
use File::Copy;
#use Sys::Syslog;

local $| = 1; # forces fflush on stdout

my $version_info = "HPE topology 5.0: Copyright (c) 2010-2018 Hewlett Packard Enterprise Development LP.  All Rights Reserved.";

############## Set Up Data Structures We Will Use #################

my $debug = 0;
my $has_topology = 0;

# various file locations
my $toporoot = $ENV{"TOPOROOT"};
if (! $toporoot) {
	$toporoot="";
}
my $topofile            = "";
my $xorgconf            = "$toporoot/etc/X11/xorg.conf";
my $cpuinfofile         = "$toporoot/proc/cpuinfo";
my $systemmeminfofile   = "$toporoot/proc/meminfo";
my $uv_base             = "$toporoot/proc/sgi_uv";
my $uv_topology         = "$toporoot/proc/sgi_uv/topology";
my $uv_hubless          = "$toporoot/proc/sgi_uv/hubless";
my $nirr_proc_file      = "$toporoot/proc/sgi_uv/nilink_rerouting";
my $dmi_sysfs_dir       = "$toporoot/sys/class/dmi/id/";
my $serial_file         = "$toporoot/sys/class/dmi/id/product_serial";
my $product_file        = "$toporoot/sys/class/dmi/id/product_name";
my $sys_bus_nodepath    = "$toporoot/sys/bus/node/devices";
my $pci_devices         = "$toporoot/sys/bus/pci/devices";
my $sys_devices         = "$toporoot/sys/devices";
my $sys_dev_mempath     = "$toporoot/sys/devices/system/memory";
my $sys_dev_nodepath    = "$toporoot/sys/devices/system/node";
my $sys_dev_cpupath     = "$toporoot/sys/devices/system/cpu";
my $cpu_ids_base        = "$toporoot/sys/devices/system/cpu/cpuN/topology";

# installed files location (HPE or Legacy SGI)
my $hpe_install_location = "$toporoot/opt/hpe/hwperf";
my $sgi_install_location = "$toporoot/opt/sgi/hwperf";
my $hpe = 0; my $hpe = 1 if (-d $hpe_install_location);
my $sgi = !$hpe;
my $install_location = $hpe_install_location if $hpe;
   $install_location = $sgi_install_location if $sgi;
my $pci_defs_file = "$install_location/custom-pci-defs";

# temporary files
my $cache_base          = "$toporoot/tmp/sgi_topology.".getpwuid($<);
my $lspci_tmp_file      = "$cache_base/lspci";
my $nodes_file          = "$cache_base/nodes_cache";
my $device_nodes_file   = "$cache_base/device_nodes_cache";
my $nodes_cpus_file     = "$cache_base/nodes_cpu_cache";
my $cpu_ids_file        = "$cache_base/cpu_ids_cache";

# cached files
my $sgi_uv_base         = "$toporoot/var/run/sgi_uv";
my $lspci_var_file      = "$sgi_uv_base/lspci";
my $nirr_var_file       = "$sgi_uv_base/nilink_rerouting";
my $topology_long       = "$sgi_uv_base/topology";
my $topology_brief      = "$sgi_uv_base/topology_brief";
my $dmi_cache_dir       = "$sgi_uv_base/dmi/";
my $memdir_cache_dir    = "$sgi_uv_base/memdir/";
my $mems_map_cache_file = "$sgi_uv_base/mems_map";
my $node_ranges_cache_file = "$sgi_uv_base/mems_map_nodes";

# system type info (official Hawks2 name not yet defined)
my $sys_type;
my @sys_types_short = qw(unknown UV1 UV2 UV3K UV3 MC990X UV4 Hawks2);
my @sys_types = ('unknown', 'UV100/1000', 'UV2000', 'UV3000',
		'UV300', 'HPE Integrity MC990 X Server',
		'UV400', 'HPE Integrity Hawks2',);
my $uv3k = 0;
my $mc990x = 0;
my $hawks2 = 0;
my $uv4 = 6;

# system serial number as reported in the topology file
my $sys_serial_number;

# system name as reported in the topology file
my $sys_name;

# partition id as reported in the topology file
my $sys_partition_id;

# hub information
my $hub_count = 0;
my %hub_list = ();
my $hub_type = 0;
use constant {	## use with $hub_type
	UV1 => 2,
	UV2 => 3,
	UV3 => 4,
	UV4 => 5,
};
my @hub_names = ('unknown', 'illegal', 'UV1', 'UV2', 'UV3', 'UV4');
my $hub_name;

# node information
my $nodecount = 0; # includes nodes of all classes, e.g. "node" and "ionode"
my $numa_nodes_found = 0;
my @node_class; # e.g. "node" or "ionode"
my @node_id;
my @node_nasid;
my @node_asic_version;
my @node_mem_size; # the amount of memory on the node
my @node_cpus;
my @node_ranges = ();
my $node_ranges = 0;
my @nodescpusdata;
my @nodesdata;
my @cpuidsdata;
my @devicenodesdata;
my @all_devices = ();
my @all_nodes = ();
my @mems_map = ();
my $mems_map = 0;
my $pmem_count = 0;

# BMC/socket information
my @bmc_id;
my $missing_sockets = 0;

# processor information
my @ints = ();
my $ints_read = 0;
my $online_cpus = "";
my $cpucount = 0;
my %cpus = ();
my @irq_ints = ();
my @irq_counts = ();
my @irq_devices = ();
my %sys_nodes_to_cpus = ();
my %blades_to_nodes = ();
my %blades_to_cpus = ();
my $have_irq_ints = 0;

# I/O information
my @custom_pci_defs = ();
my $lspci_file;

# Devices
my $fibcount = 0;
my $gpgpucount = 0;
my $copcount = 0;
my $gpucount = 0;
my $ibcount = 0;
my $netcount = 0;
my $scsicount = 0;
my $satacount = 0;
my $usbcount = 0;
my $vancount = 0;
my $vgacount = 0;
my $raidcount = 0;
my $nvmccount = 0;
my $mgadevid = "";
my $mgadevice = "";

my @pcidata;
my %pcidevs = ();
my %devtypes = ();
my $lastpciid = -1;
my %pcibusincrs = ();

# Footnotes - each footnote is a hash holding the footnote string, key, and
# any instances of tagged hubs, devices, etc. Footnotes are identified by a
# unique constant called a flag.
#
# To implement a new footnote, define a new flag, define FOOTNOTE_STR, and
# call append_footnote_key at least once.
my $footnotes_enabled = 1;
my @footnotes = ();			# array of footnote hashes
my @active_footnotes = ();		# array of footnote flags
use constant {
	# Footnote flags
	F_DEV_DESC_MISSING              => 0,
};

$footnotes[F_DEV_DESC_MISSING]{FOOTNOTE_STR} = "Device description missing from pci.id database; consider updating by running update-pciids.";

# router information
my $routercount = 0;
my @router_id;
my @router_class; # e.g. NL5router or ???

# memory information
my $block_size_bytes = 0;
my $base_address = 0;
my $last_address = 0;
my $total_kb_memory; # total amount of system memory in kB

# i/o information
my $risercount = 0;
my $io_bases = 0;
my $io_risers = 0;
my $pcie_slots = 0;
my $pcie_cards = 0;
my %risers = ();
my %sktids = ();
my %io_slots = ();
my %iios = ();

# coprocessor information
my %KNC = ();
$KNC{"2250"} = " KNC 2250 60core 8Gb 1.05Ghz 5.0GT/s ";
$KNC{"225c"} = " KNC 225c 61core 8Gb 1.09Ghz 5.5GT/s ";
$KNC{"225d"} = " KNC 225d 57core 3Gb 1.09Ghz 5.0GT/s ";

my $copindex = 0;
my %copnodes = ();

# gfx infomartion
my %screens = ();
my %screen_numbers = ();
my %displays = ();
my $displaycount = 0;
my %devices = ();
my %subdevices = ();
my %subscreens = ();
my %devids = ();
my %basedev = ();
my %inpdevices = ();
my %monitors = ();
my %usedisplays = ();
my %terminals = ();
my %inputs = ();
my %assigned = ();
my %pci_nodes = ();
my %logdisplay = ();
my $connected = 0;

# ------------------------------------------------
#
# process options

my $mode_cop = 0;
my $mode_nvmc = 0;
my $mode_cpu = 0;
my $mode_dsk = 0;
my $mode_gfx = 0;
my $mode_gfx_only = 0;
my $gpudirect = 0;
my $mode_net = 0;
my $mode_node = 0;
my $mode_rtr = 0;
my $mode_summ = 0;
my $mode_irq_counts = 0;

my $headers = 1;
my $help = 0;

my $get_node = "";
my $get_cpus = "";
my $get_pciids = "";
my $get_systype = "";

# set this to "yes" if we suspect the existence of hardware we don't know about
my $unexpected_findings = 0;
my $unexpected_count = 0;
my @unexpected;
my $verbose = 0;
my $version = 0;

my $arg_all = 0;
my $arg_affinity = 0;
my $arg_evt = 0;
my $arg_io = 0;
my $arg_hdrs = 0;
my $arg_nox = 1;    # removes the X Display from output
my $arg_show_x = 0; # adds the X Display to output
my $arg_nomga = 0;  # removes the Matrox VGA from output
my $arg_xorg = 0;   # displays only X related info
my $arg_irqs = 0;
my $arg_tt = 0;
my $arg_notopo = 0;
my $arg_topofile = "";
my $arg_lspci = "";
my $uv_rebuild_lspci = 0;

$mode_gfx = 1 if (index($0,"gfxtopology") >= 0);

my $ret = &GetOptions (
	"all"          => \$arg_all,
	"affinity"     => \$arg_affinity,
	"check"        => \$unexpected_findings,
	"cops"         => \$mode_cop,
	"cpus"         => \$mode_cpu,
	"disks"        => \$mode_dsk,
	"d+"           => \$debug,
	"debug=i"      => \$debug,
	"events"       => \$arg_evt,
	"gfx"          => \$mode_gfx,
	"gpudirect"    => \$gpudirect,
	"io"           => \$arg_io,
	"irqs"         => \$arg_irqs,
	"h+"           => \$help,
	"noheaders"    => \$arg_hdrs,
	"nox"          => \$arg_nox,
	"show_x"       => \$arg_show_x,
	"lspci=s"      => \$arg_lspci,
	"x+"           => \$arg_xorg,
	"xorg"         => \$arg_xorg,
	"help"         => \$help,
	"get_cpus=s"   => \$get_cpus,
	"get_node=s"   => \$get_node,
	"get_pciids"   => \$get_pciids,
	"get_systype"  => \$get_systype,
	"networks"     => \$mode_net,
	"nvmcs"        => \$mode_nvmc,
#	"node_only=i"  => \$get_node,		# deprecated
	"nodes"        => \$mode_node,
	"routers"      => \$mode_rtr,
	"s+"           => \$mode_summ,
	"summary"      => \$mode_summ,
	"topo=s"       => \$arg_topofile,
	"tt"           => \$arg_tt,
	"v+"           => \$verbose,
	"verbose=i"    => \$verbose,
	"version"      => \$version,
	"xorgconf=s"   => \$xorgconf,
	"reset-cache"  => \$uv_rebuild_lspci,
	"N+"           => \$arg_notopo,
	"notopo"       => \$arg_notopo,
);
if (! $ret) {
	$has_topology = 1; # get full usage
	usage();
}

if ($version) {
	printf "%s\n", $version_info;
	exit 0;
}

if ($gpudirect) {
	do_gpudirect();
	exit 0;
}

# choose one of these sources for the topology file
if (($arg_topofile ne "") && (! -e $arg_topofile)) {
	printf("--topo=%s  %s not found\n", $arg_topofile, $arg_topofile);
	exit(1);
}
my @tfiles = (
	$arg_topofile,
	$topology_brief,
	$topology_long,
	$uv_topology
);
foreach my $tfile (@tfiles) {
	print "trying $tfile\n" if $debug > 1;
	if (-e $tfile) {
		$topofile = $tfile;
		last;
	}
}

# The fast topology file was added in /var/run in stout702.
# Fall back to the raw topology file if the fast file is not present.

# Older systems do not have pcibus info in the topology_brief file
# so autoset the --tt option.
if (!$arg_tt) {
	if ((-e $topology_brief) && (open SYS_PCI, "grep -c pcibus $topology_brief|")) {
		while (<SYS_PCI>) {
			if (/(\d+)/) {
				printf ("pcibus cnt %d\n", $1) if $debug;
				$arg_tt = 1 if ($1 == 0);
			}
		}
		close(SYS_PCI);
	} else {
		$arg_tt = 1;
	}
}
print "arg_tt is on\n" if ($arg_tt && $debug);

# $arg_tt is set if the short topology file had no pcibus info
# or there is no short topology file; if either case use the raw (/proc) file
if ($arg_tt && $topofile eq $topology_brief) {
	$topofile = $uv_topology;
}

if (-e $topofile) {
	if ($arg_notopo) {
		$has_topology = 0;
	} elsif (-e $uv_hubless and not $debug) {
		$has_topology = 0;
		print "Interim Fix: Hubless UV detected, hwperf info temporarily ignored.\n";
	} else {
		$has_topology = 1;
		print "Using topology from \'$topofile\'\n" if $debug;
		# fail if we can't read $topofile (i.e. $topofile is in /proc and we're not root)
		if (!(-r $topofile)) {
			warn ("Current user does not have permission to read $topofile.\n".
			      "Restart sgi_configuration service as root to generate an ".
			      "appropriate topology file.\n");
			exit 2;
		}
	}
} else {
	$has_topology = 0;
	if (-e $uv_base) {
		warn ("No topology information found. Is the hwperf module installed?\n");
	}
}

# Some options are not yet supported without an SGI topology file:
if (! $has_topology) {
	if ($arg_evt || $mode_rtr || $get_node ||
		$get_pciids || $get_systype || $get_cpus) {
		if ($arg_evt) {
			printf("--events not supported\n");
		}
		if ($mode_rtr) {
			printf("--routers not supported\n");
		}
		if ($get_node) {
			printf("--get_node not supported\n");
		}
		if ($get_pciids) {
			printf("--get_pciids not supported\n");
		}
		if ($get_systype) {
			printf("--get_systype not supported\n");
		}
		if ($get_cpus) {
			printf("--get_cpus not supported\n");
		}
		printf("see --help\n");
		exit;
	}
}

$headers = 0 if ($arg_hdrs || $get_cpus ne "" || $get_node ne "" ||
                 $get_pciids ne "" || $get_systype ne "");
$footnotes_enabled = $headers; #headers implies footnotes

$mode_gfx = 1 if $arg_xorg; # forces
$arg_irqs = 1 if $arg_affinity;
$mode_gfx = 1 if $get_node =~ /^:/ || $get_cpus =~ /^:/;
$mode_cop = 1 if $get_node =~ /^mic:/ || $get_cpus =~ /^mic:/;

if ($arg_irqs && $arg_io == 0 && $has_topology) {
	$arg_io = 1 unless ($mode_cop ||
	                    $mode_dsk ||
	                    $mode_gfx ||
	                    $mode_net ||
	                    $mode_nvmc);
}

if ($get_pciids && $arg_io == 0) {
	$arg_io = 1 unless ($mode_cop ||
	                    $mode_dsk ||
	                    $mode_gfx ||
	                    $mode_nvmc ||
	                    $mode_net);
}

if ($arg_all) {
	$arg_io = 1;
	$mode_summ = 1;
	$mode_cpu = 1;
	$mode_node = 1;
	if ($has_topology) {
		$mode_rtr = 1;
	}
}

if ($arg_io) {
	$mode_cop = 1;
	$mode_dsk = 1;
	$mode_gfx = 1;
	$mode_net = 1;
	$mode_nvmc = 1;
}

if ($mode_gfx) {
	$mode_gfx_only = 1 unless ($mode_cop ||
	                           $mode_dsk ||
	                           $mode_net ||
	                           $mode_nvmc);
}

$mode_summ = 1
	unless ($mode_cop ||
	        $mode_cpu ||
	        $mode_dsk ||
	        $mode_gfx ||
	        $mode_net ||
	        $mode_node ||
	        $mode_nvmc ||
	        $mode_rtr ||
	        $get_cpus ne "" ||
	        $get_node ne "" ||
	        $get_pciids ne "" ||
	        $get_systype ne "");

$arg_nox = 1 unless $mode_gfx;
$arg_nox = 1 if $arg_irqs;
$arg_nox = 0 if $get_node =~ /^:/ || $get_cpus =~ /^:/;
$arg_nox = 0 if $arg_show_x;

$mode_irq_counts = 1 if ($arg_irqs && $verbose);

if (($arg_lspci ne "")  && (! -e $arg_lspci)) {
	printf("--lspci=%s  %s not found\n", $arg_lspci, $arg_lspci);
	exit(1);
}

if ($debug) {
	printf "brand: %s\n", $hpe? "hpe" : $sgi? "sgi" : "uknown";
	print "arg_affinity on\n" if $arg_affinity;
	print "arg_io on\n" if $arg_io;
	print "arg_irqs on\n" if $arg_irqs;
	print "arg_nox on\n" if $arg_nox;
	print "arg_xorg on\n" if $arg_xorg;
	print "get_cpus $get_cpus\n" if $get_cpus ne "";
	print "get_node $get_node\n" if $get_node ne "";
	print "get_pciids $get_pciids\n" if $get_pciids ne "";
	print "get_systype $get_systype\n" if $get_systype ne "";
	print "mode_cop on\n" if $mode_cop;
	print "mode_cpu on\n" if $mode_cpu;
	print "mode_dsk on\n" if $mode_dsk;
	print "mode_gfx on\n" if $mode_gfx;
	print "mode_gfx_only on\n" if $mode_gfx_only;
	print "mode_net on\n" if $mode_net;
	print "mode_node on\n" if $mode_node;
	print "mode_nvmc on\n" if $mode_nvmc;
	print "mode_rtr on\n" if $mode_rtr;
	print "mode_summ on\n" if $mode_summ;
	print "verbose $verbose\n";
}


# determine the system type before processsing topology entries

# first, check if topology file exists
if ($has_topology) {
	open FILE, "grep -m 1 UVHub $topofile |";
	my $hubinfo = readline(FILE);
	close FILE;
	chomp $hubinfo;
	print "--- From $topofile: $hubinfo\n" if $debug;

	if ($hubinfo =~ /UVHub (\d+)\.\d+/) {
		$hub_type = $1;
		$hub_name = $hub_names[$hub_type];
		printf "--- hub_type $hub_type ($hub_name)\n" if $debug;
	}
}

my $dmi_prod_name = get_cached_data("product_name", $dmi_cache_dir,
                                    $dmi_sysfs_dir, "dmi");
my $dmi_prod_ver  = get_cached_data("product_version", $dmi_cache_dir,
                                    $dmi_sysfs_dir, "dmi");
my $dmi_bios_vend = get_cached_data("bios_vendor", $dmi_cache_dir,
                                    $dmi_sysfs_dir, "dmi");

if ($dmi_bios_vend eq "SGI.COM" && $dmi_prod_ver eq "1.0") {
	$sys_type = 1;
} elsif ($dmi_prod_name eq "UV2000") {
	$sys_type = 2;
} elsif ($dmi_prod_name eq "UV3000") {
	$sys_type = 3;
} elsif ($dmi_prod_name eq "UV300") {
	$sys_type = 4;
} elsif ($dmi_prod_name eq "HPE Integrity MC990 X Server") {
	$sys_type = 4;
	$mc990x = 1;
} elsif ($dmi_prod_name eq "UV400") {
	$sys_type = $uv4;
} elsif ($dmi_prod_name eq "Integrity Hawks2") {
	$sys_type = $uv4;
	$hawks2 = 1;
}
print "sys_type: $sys_type from dmi(vend,prod):$dmi_bios_vend,$dmi_prod_name\n\n" if $debug > 1;

############################## Events Section ##############################

if ($help) {
	print "has_topology=$has_topology";
	usage();
}

if ($arg_evt) {
	if ($< == 0) {
		nilink_reroute_event();
		exit 0;
	} else {
		print "Event information can only be accessed by root.\n";
		exit 1;
	}
}

################### Collect Information - Fill In Above Data Structures #######################

system("mkdir -p $cache_base") &&
	die("Could not initialize cache directory $cache_base\n");

if (! -d $cache_base) {
	system("mkdir -p $cache_base") &&
	    die("Could not initialize cache directory $cache_base\n");
}

# Arch dependent conversions; if none, return verbatim
sub get_systype
{
	my $sys_label = get_contents($product_file);
	my $sys = get_systype_details($sys_label);
	print "$sys\n";
	exit;
}
get_systype() if $get_systype and $has_topology and $hpe;

sub get_systype_details
{
	my $sys = shift;
	# (Update needed: use custom defs file)
	$sys = "SDFlex" if $sys =~ /Superdome Flex/;
	$sys = $sys . get_systype_details_hub() if $verbose;
	return $sys;
}

sub get_systype_details_hub
{
	my $chip = "";
	open FILE, "grep -m 1 UVHub $topofile |";
	my $hubinfo = readline(FILE);
	close FILE;
	print "gsd: $topofile: $hubinfo\n" if $debug > 1;
	if ($hubinfo =~ /UVHub (\d+)\.(\d+)/) {
		my $hub = $1;
		my $rev = $2;
		$chip = " UV4"  if $hub == 5 and $rev == 0;
		$chip = " UV4A" if $hub == 5 and $rev == 1;
		printf "gsd: hub:$hub.$rev chip:$chip\n" if $debug > 1;
	}
	return $chip;
}

if ($has_topology) {
	open(FILE, "< $topofile") || die("can't open topology file: $topofile");
	my @topodata = readline(FILE);
	close(FILE);
	my $topo_entry;
	foreach $topo_entry (@topodata)
	{
		chomp $topo_entry;
		print "\n\n+++ entry: $topo_entry" if ($debug > 3);

	# UV100/1000
	# partition 1 uvmid1-sys local uvtype 2.0, coherency_domain 0, region_size 1, N 4, M 36, system serial number UVL-00000001
	# hub 0 r001i01b00 local asic UVHub 2.0, nasid 0x0,

	# UV2000/3000
	# partition 0 harp10-sys local uvtype 3.0, coherency_domain 0, region_size 1, N 4, M 36, system serial number UV2-00000010
	# hub 0 r001i01b00h0 local asic UVHub 3.0, nasid 0x0,

	# UV300
	# partition 0 harp0-sys local uvtype 5.0, coherency_domain 0, region_size 1, N 4, M 36, system serial number UV3-00000100
	# hub 0 r001i01b00h0 local asic UVHub 4.0, nasid 0x0, dist 10:50:50:50

	# UV400
	# partition 0 uv4test16-sys local uvtype 7.0, coherency_domain 0, region_size 1, N 2, M 0, system serial number UV400-00000016
	# hub 0 r001i01b00h0 local asic UVHub 5.0, nasid 0x2, dist 10:16:16:19

		if ($topo_entry =~ /^partition (\d+)\s+(\S+).*?uvtype \d+.\d+,.*?system serial number (\S+)/) {
			$sys_partition_id = $1;
			$sys_name = $2;
			$sys_serial_number = $3;
		} elsif ($topo_entry =~ /^hub (-1)\s+(\S+).*?asic ([^,]+?)$/) {
			# Count the missing hublets, assume they are unpopulated sockets
			$missing_sockets++;
			printf("--- Missing socket on id %s\n", $2) if $debug > 1;
		} elsif ($topo_entry =~ /^hub (\d+)\s+(\S+).*?asic ([^,]+?),\snasid\s+(0x[[:xdigit:]]+?),/) {
			# hub 0 r001i01b00h0 local asic UVHub 4.1, nasid 0x0, (uv3)
			# hub 1 r001i01b00h1 local asic UVHub 4.1, nasid 0x2,
			# hub 1 r001i01b00h0 local asic UVHub 5.0, nasid 0x0 (uv4)
			# hub 0 r001i01b00h1 local asic UVHub 5.0, nasid 0x2
			print "\n" if $debug > 3;
			my $nodenum = $1;
			my $blade = $2;
			$nodecount++;
			$bmc_id[$1] = $blade;
			$node_class[$1] = "node";
			$node_id[$1] = get_socket_id($blade);
			$node_asic_version[$1] = $3;
		 	return_systype($sys_type, "$3") if ($get_systype ne "") and $sgi;
			# (does not return)
			$node_nasid[$1] = hex("$4");
			printf("--- Node %3d id %s blade %s bmcid %s nasid 0x%04x\n",
				$1, $node_id[$1], $blade, $bmc_id[$1], $node_nasid[$1]) if $debug > 3;
			if ($blade =~ /(r\d\d\di\d\db\d\d)/) {
				if (undef $hub_list{$1}) {
					$hub_count++;
					$hub_list{$1}++;
				}
			}
		} elsif ($topo_entry =~ /^router\s+(\d+)\s+(\S+).*?(NL\S+)/) {
			my $id = $2;
			my $class = $3;
			if ($hub_type >= UV2) { # only count first hublet
				if ($id =~ /(r\d\d\di\d\dr\d\d)h0/) {
					$id = $1;
				} else {
					next;
				}
			}
			$router_id[$routercount] = $id;
			$router_class[$routercount] = $class;
			$routercount++;
		} elsif ($topo_entry =~ /^cpu\s+(\d+)\s+(\S+?)#(\d+)_(\d+)-(\d+) .*?(\d+)MHz.*?arch (\S+?)/) {
			# cpu   0 r001i01b00h0#00_00-000 socketid  0 coreid  0 apicid   0 os_node 0 nasid 0x0 local freq 2800MHz arch UV
			print "\n" if $debug > 3;
			my $cpunum = int($1);
			$cpucount++;
			if (exists $cpus{$cpunum}) {
				printf ("Duplicate CPU entry: cpu %d\n", $cpunum);
			} else {
				my $loc = get_socket_id($2);
				$cpus{$cpunum} = {
					blade => $loc,
					bmcid => $2,
					physid => $3,
					coreid => $4,
					apicid => int($5),
					speed => $6,
					arch => $7
				};
				printf("--- CPU %4d blade %s bmcid %s physid %4d coreid %4d apicid %4d\n",
					$1, $loc, $2, $3, $4, $5) if $debug > 4;
			}
		} elsif ($topo_entry =~ /^ionode\s+(\d+)\s+(\S+?) .*?asic\s+(\S+?),\s+nasid (0x\S+?),/) {
			print "\n" if $debug > 3;
			print STDERR "WARNING: Untested ionode support!!\n";
			$nodecount++;
			$node_class[$1] = "ionode";
			$node_id[$1] = $2;
			$node_asic_version[$1] = $3;
			$node_nasid[$1] = hex("$4");
		} elsif ($topo_entry =~ /^pcibus\s+([[:xdigit:]]+):([[:xdigit:]]+)\s+(\w+)\s(.*)/) {
			# find blades with attached I/O
			my $pciseg = hex("$1");
			my $pcibus = hex("$2");
			my $pcidb = $1 . ":" . $2;
			my $pciid = ($pciseg << 8) | $pcibus;
			my $nid = $3;
			my $io_type = $4;
			my $iio = "";
			# special BASE IO devices that are not on BUS 0000:00 ...
			my $special_pcidb = "";
			$special_pcidb = "0000:C3" if $hub_type == UV4 && $pciid == 0;

			chomp $topo_entry;
			chomp $io_type;
			if ($io_type =~ /(.*)\s\(IIO Stack (\d+)\)/) {
				$io_type = $1;
				$iio = $2;
			}
			print "\n--- bus pciseg $pciseg pcibus $pcibus pcidb $pcidb pciid $pciid nid $nid io_type:$io_type iio:$iio\n\ttopo_entry:$topo_entry\n" if $debug > 1;

			if ($io_type =~ /BASE IO/) {
				# pcibus 0000:00 r001i01b00h0 BASE IO
				$io_slots{$pcidb} = 0;
				printf ("\t--- io_slots{%s} = %s\n", $pcidb, $io_slots{$pcidb}) if $debug;
				if ($special_pcidb ne "") {
					$io_slots{$special_pcidb} = 0;
					printf ("\t--- io_slots{%s} = %s\n",
						$special_pcidb, $io_slots{$special_pcidb}) if $debug;
				}
			} elsif ($io_type =~ /at ([0-9a-fA-F:.]+) \(slot\s+(\d+)\)/) {
				# pcibus 0000:01 PPB at 0000:00:02.00 (slot 1)
				$nid = "PCISLOT";
				my $slot = $2;
				print "--- slot $pciseg $pcibus $pcidb slot:$slot\n" if $debug > 1;
				if (exists $io_slots{$pcidb}) {
					printf ("Error: Duplicate I/O Slot entry: %s (pcidb %s)\n",
						$pcidb, $io_slots{$pcidb});
				} else {
					$io_slots{$pcidb} = $slot;
					$pcie_cards++;
					printf ("\t--- io_slots{%s} = %s (#cards:%d)\n",
						$pcidb, $io_slots{$pcidb}, $pcie_cards) if $debug;
				}
			} elsif ($io_type =~ /at ([[:xdigit:]]+:[[:xdigit:]]+):.*/) {
				# pcibus 0001:03 PPB at 0001:00:03.02
				print "--- PPB  $pciseg $pcibus $pcidb data:$1\n" if $debug > 1;
				if (exists $io_slots{$pcidb}) {
					printf ("Error: Duplicate I/O Slot entry: %s (pcidb %s)\n",
						$pcidb, $io_slots{$pcidb})
						if $hub_type != UV4 || $pcidb ne "0000:C3"; # Base I/O special device
				} else {
					$io_slots{$pcidb} = $1;
					printf ("\t--- io_slots{%s} = %s (#cards:%d)\n",
						$pcidb, $io_slots{$pcidb}, $pcie_cards) if $debug;
				}
			}
			next if $nid eq "PPB";
			next if $io_type =~ /NODE\s+IO/;
			print "--- topo $risercount $pciseg $pcibus $lastpciid '$pcibusincrs{$lastpciid}' $nid $io_type\n\t--- $topo_entry\n" if $debug > 1;
			$io_bases++ if $io_type eq "BASE IO";
			$io_risers++ if $io_type eq "Riser";
			$io_risers++ if $io_type eq "PCIe IO";
			$pcie_slots++ if $io_type eq "PCIe SLOT";
			$pcie_slots++ if $nid eq "PCISLOT";
			$risercount++;
			print "\t--- io_bases $io_bases io_risers $io_risers pcie_slots $pcie_slots risercount $risercount\n" if $debug > 1;
			if ($nid eq "PCISLOT") {
				printf "--- skip IO riser\n" if $debug > 1;
			} else {
				my $sktid = get_socket_id($nid);
				my $pcibi = 0;
				if ($iio ne "" and $iio ne "0") {
					my $iioid = $sktid . ',' . $iio;
					$iios{$iioid} = $sktid;
					printf ("\t--- iios{%s} = %04x\n", $iioid, $iios{$iioid}) if $debug;
				} elsif (exists $risers{$sktid}) {
					printf ("Error: Duplicate I/O Slot entry: (risers{%s} = %s) \n",
						$sktid, $risers{$sktid}) if $debug;
				} else {
					my $pciid = ($pciseg << 8) | $pcibus;
					$risers{$sktid} = $pciid;
					printf ("\t--- risers{%s} = %04x\n", $sktid, $risers{$sktid}) if $debug;

					# need pci bus increment for later
					if ($lastpciid < 0) {
						$lastpciid = $pciid;
					} else {
						$pcibi = $pciid - $lastpciid;
						$pcibusincrs{$lastpciid} = $pcibi;
					}
					print "\t--- pciid $pciid $pcibi pcibusincrs{$lastpciid}\n" if $debug>2;
						$lastpciid = $pciid;
				}
			}
		} elsif ($topo_entry =~ /^pcibus\s+([0-9a-fA-F]+):([0-9a-fA-F]+)\s+.*/) {
			# parse pcibus PPB and NODE IO lines
			;
		} elsif ($topo_entry =~ /^numalink\:*\s+.*/) {
			;
		} else {
			# if this is not a comment there might be hardware we don't know about
			if (!($topo_entry =~ /^\s?\#/)) {
				$unexpected[$unexpected_count++] = $topo_entry;
			}
		}
	}
} else {
	# there is no topology file, so determine as much as we can in other ways
	my $one_node=0;
	if (cache_device_nodes()) {
		# if there are no numa_node entries in /sys we have to assume only one node
		if (-e $device_nodes_file) {
			unlink($device_nodes_file);
		}
		$one_node=1;
		cache_pci_node0();
	}
	cache_nodes_info();
	cache_cpu_ids();

	$nodecount = parse_nodes_info();
	# sanity check the above assumption
	if ($one_node && $nodecount > 1) {
		printf("Only one node was assumed, but %d seen; aborting\n",
			$nodecount);
		exit(1);
	}

	if (parse_device_nodes()) {
		printf("invalid device/node file %s; aborting\n", $device_nodes_file);
		exit(1);
	}

	$cpucount = parse_cpu_ids();
	$sys_name = `uname -n`;
	chomp($sys_name);
	if (-r $serial_file) {
		$sys_serial_number = get_contents($serial_file);
	} else {
		$sys_serial_number = "($serial_file not readable)";
	}
	$sys_partition_id = 0;
}

if ($mode_cop || $mode_dsk || $mode_gfx || $mode_net || $mode_nvmc || $mode_summ) {
	# determine cached lspci file
	if ($arg_lspci ne "") {
		$lspci_file = $arg_lspci;
	} elsif (-r $lspci_var_file) {
		$lspci_file = $lspci_var_file;
		my $pciid_db="/usr/share/pci.ids";
		if (($uv_rebuild_lspci) || (-M $lspci_file > -M $pciid_db)) {
			cache_pci_info($lspci_file);
		} elsif ($debug) {
			printf("Using cached pci info at $lspci_var_file\n");
		}
	} else {
		$lspci_file = $lspci_tmp_file;
		cache_pci_info($lspci_file);
	}

	# pull in relevant pci info
	parse_lspci_devices();
}

$arg_nox = 1 unless ($gpgpucount > 0 || $vgacount > 0 || $verbose);
$arg_nox = 0 if $get_node =~ /^:/ || $get_cpus =~ /^:/;
if ($debug && $arg_nox) {
	print "arg_nox set: $arg_nox gpgpucount $gpgpucount vgacount $vgacount verbose $verbose\n";
}

if ($mode_cop || $mode_dsk || $mode_gfx || $mode_net || $mode_nvmc) {
	# pull in xorg.conf
	if ($mode_gfx && !$arg_nox && open(FILE, "< $xorgconf")) {
		print "---\nUsing Xorg Config Info from $xorgconf\n" if $debug;
		my @xorgconf = readline(FILE);
		close (FILE);
		my $line;
		my $section = "";
		my $id = "";
		my $devid = "";
		my $dvrid = "";
		my $busid = "";
		my $monid = "";
		my $inpdevid = "";
		my $monvend = "";
		my $monmodel = "";
		my $subscreen = "";
		my $newsection = 1;
		my %options = ();

		foreach $line (@xorgconf) {
			if ($debug > 1 && $newsection && $section ne "") {
				print "\nSection: $section\n";
				$newsection = 0;
			}

			printf ".................................%12s: %s",
				$section, $line if $debug > 2;

			next if ($line =~ /^\s+#/);

			if ($line =~ /EndSection/) {
				if ($section eq "screen") {
					$devids{$id} = $devid;
					print "devids{$id} = $devids{$id}\n" if $debug;
					$usedisplays{$id} = $options{"UseDisplayDevice"};
					print "usedisplays{$id} = $usedisplays{$id}\n" if $debug > 1;
					$monitors{$id} = $monid;
					print "monitors{$id} = $monitors{$id}\n" if $debug > 1;
					if ($id =~ /(\S+)/) {
						my $bdev = $1;
						$basedev{$id} = $bdev;
						print "basedev{$id} = $basedev{$id}\n" if $debug > 1;
					}
				} elsif ($section eq "device") {
					$devices{$id} = $busid;
					if ($dvrid eq "mga") {
						$mgadevice = $id;
					}
					printf ("devices{%s} = %x\n", $id, $devices{$id}) if $debug;
					if ($subscreen ne "") {
						my $bdev = "what?";
						if ($id =~ /(\S+)/) {
							$bdev = $1;
						}
						$basedev{$id} = $bdev;
						print "basedev{$id} = $basedev{$id}\n" if $debug > 1;
						my $subdev = $subdevices{$busid} + 0;
						if ($subdev < $subscreen + 1 ) {
							$subdevices{$busid} = $subscreen + 1;
							printf("subdevices{%x} = %s\n", $busid, $subdevices{$busid}) if $debug > 1;
						}
						$subscreens{$id} = $subscreen;
						print "subscreens{$id} = $subscreens{$id}\n" if $debug > 1;
					}
				} elsif ($section eq "inputdevice") {
					$inpdevices{$id} = $dvrid;
					print "inpdevices{$id} = $inpdevices{$id}\n" if $debug;
				} elsif ($section eq "monitor") {
					my $term;
					$term = $monvend if $monmodel eq "Unknown";
					$term = $monmodel if $monvend eq "Unknown";
					$term = $monvend .":". $monmodel if $term eq "";
					$terminals{$id} .= $term;
					print "terminals{$id} = $terminals{$id}\n" if $debug;
				}
				$id = "";
				$busid = 0;
				$section = "";
				$newsection = 1;
				%options = ();
			}

			if ($line =~ /^\s*Section\s+"ServerLayout"/) {
				$section = "serverlayout";
				next;
			}

			if ($line =~ /^\s*Section\s+"Screen"/) {
				$section = "screen";
				next;
			}

			if ($line =~ /^\s*Section\s+"Device"/) {
				$section = "device";
				next;
			}

			if ($line =~ /^\s*Section\s+"InputDevice"/) {
				$section = "inputdevice";
				next;
			}

			if ($line =~ /^\s*Section\s+"Monitor"/) {
				$section = "monitor";
				next;
			}

			if ($line =~ /^\s*Identifier\s+"([^"]+)"/) {
				$id = "$1";
				print "ID: $id\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*Option\s+"(\w+)"\s+"(\w+)"/) {
				$options{$1} = ${2};
				print "Option: options{$1} = $options{$1}\n" if $debug > 1;
				next;
			}

			if ($section eq "serverlayout") {
				my $scrn;
				my $key;
				my $data;
				my $args;

				if ($line =~ /^\s*Screen\b\s+(.+)/) {
					$args = $1;
					print "Screen: $args\n" if $debug > 1;
					if ($args =~ /\s*(\d+)\s+"([^"]+)"/) {
						$scrn = "$1";
						$key = $id . "." . "$1";
						$data = $2;
					} elsif ($args =~ /"(\S+)"/) {
						$scrn = "0";
						$key = $id . ".0";
						$data = $1;
					}
					$screens{$scrn} = $key;
					$screen_numbers{$key} = $scrn;
					$displays{$key} = $data;
					print "screens{$scrn} = $screens{$scrn}\n" if $debug > 1;
					print "displays{$key} = $displays{$key}\n" if $debug;
					print "screen_numbers{$key} = $screen_numbers{$key}\n\n" if $debug > 1;
					next;
				}
				if ($line =~ /^\s*InputDevice\b\s+"(\S+)"\s+"(\S+)"/) {
					$inputs{$1} = $2;
					print "inputs{$1} = $inputs{$1}\n" if $debug;
				}
				next;
			}

			if ($line =~ /^\s*InputDevice\b\s+"(\S+)"/) {
				$inpdevid = "$1";
				print "InputDevice: $inpdevid\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*Device\b\s+"([^"]+)"/) {
				$devid = "$1";
				print "Device: $devid $busid\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*Screen\b\s+(\d+)/) {
				$subscreen = "$1";
				print "Screen: $subscreen\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*Driver\b\s+"(\S+)"/) {
				$dvrid = "$1";
				print "Driver: $dvrid\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*Monitor\b\s+"(\S+)"/) {
				$monid = "$1";
				print "Monitor ID: $monid\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*VendorName\b\s+"(\S+)"/) {
				$monvend = "$1";
				print "Monitor Vendor: $monvend\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*ModelName\b\s+"([^"]+)"/) {
				$monmodel = "$1";
				print "Monitor Model: $monmodel\n" if $debug > 1;
				next;
			}

			if ($line =~ /^\s*BusID\s+"(\S+)"/) {
				if ($1 =~ /(\d+)@(\d+):(\d+):(\d+)*/) {
					$busid = (($2 * 256 + $1) * 256 + $3) * 256 + $4;
				} elsif ($1 =~ /(\d+):(\d+):(\d+)*/) {
					$busid = ($1 * 256 + $2) * 256 + $3;
				}
				printf ("BusID: %x\n", $busid) if $debug > 1;
				next;
			}
		}
	}

	if ($debug) {
		print "\n---\n";
		foreach my $disp (sort keys (%displays)) {
			my $display = $displays{$disp};
			my $devid = $devids{$display};
			my $device = $devices{$devid};
			printf "DISP %x %s %s %s\n", $device, $disp, $display, $devid;
			$displaycount += 1;
		}
		print "\n---\n";
		foreach my $device (sort bynumber keys (%pcidevs)) {
			printf("%s %x %s\n", $devtypes{$device}, $device, $pcidevs{$device});
		}
		print "MGA $mgadevid $mgadevice\n";
		print "\n---\n";
	}
}

# now lets get stuff out of $cpuinfofile
open(FILE, "< $cpuinfofile") || die("can't open cpu info file: $cpuinfofile");
my @cpuinfodata = readline(FILE);
close (FILE);
my $cpuinfo_entry;
my $curcpu = -1;
foreach $cpuinfo_entry (@cpuinfodata) {
	if ($cpuinfo_entry =~ /^processor\s*:\s*(\d+).*/) {
		if (! exists $cpus{$1}) {
			printf ("Unknown CPU %s in %s\n", $1, $cpuinfofile);
			$curcpu = -1;
		} else {
			$curcpu = $1;
		}
	}

	next if ($curcpu < 0);

	if ($cpuinfo_entry =~ /^cpu family\s*:\s+(.*)/) {
		my $t = $1;
		chomp $t;
		$cpus{$curcpu}->{"family"} = $t;
	} elsif ($cpuinfo_entry =~ /^model\s*:\s+(\d+).*/) {
		my $t = $1;
		chomp $t;
		$cpus{$curcpu}->{"model"} = $1;
	}

	if (! $has_topology) {
		if ($cpuinfo_entry =~ /^cpu MHz\s*:\s+(\d+).*/) {
			my $t = $1;
			chomp $t;
			$cpus{$curcpu}->{"speed"} = $t;
		}
	}
}

# now grab cpu cache data
foreach my $i (keys %cpus) {
	my $cdir = "$sys_dev_cpupath/cpu$i/cache";

	opendir(my $dh, $cdir) || print "Can't open cache dir for cpu $i: $!" && next;
	my @dirs = grep { /^index\d+/ } readdir($dh);
	closedir($dh);

	foreach my $j (@dirs) {
		my $level_file = "$cdir/$j/level";
		my $type_file = "$cdir/$j/type";
		my $size_file = "$cdir/$j/size";
		my ($level, $type, $size);

		open(FILE, "< $level_file") || die("can't open cpu cache type file (cpu${i}, $level_file): $!");
		$level = <FILE>;
		chomp($level);
		close(FILE);

		open(FILE, "< $type_file") || die("can't open cpu cache level file (cpu${i}, $type_file): $!");
		$type = <FILE>;
		chomp($type);
		close(FILE);

		open(FILE, "< $size_file") || die("can't open cpu cache size file (cpu ${i}, $size_file): $!");
		$size = <FILE>;
		$size =~ /^(\d+)K/;
		$size = $1;
		close(FILE);

		my $cl = "l$level";
		my $curcache;

		if ($type =~ /^Data$/) {
			$curcache = "d";
		} elsif ($type =~/^Instruction$/) {
			$curcache = "i";
		} elsif ($type =~ /^Unified$/) {
			$curcache = "u";
		} else {
			# we don't know about a this type - ignore it but warn
			$unexpected[$unexpected_count++] = sprintf "Unknown cache type '%s' at level %s for cpu %s.\n",
			    $type, $level, $i;
		}

		next if (!$curcache);

		if (exists $cpus{$i}->{$cl} &&
			(($curcache eq "u") || ($cpus{$i}->{$cl} =~ m{\d$curcache}))) {
			$unexpected[$unexpected_count++] = sprintf "Already seen %s cache level %s on cpu %s\n",
			    $type, $level, $i;
			next;
		} else {
			if (! exists $cpus{$i}->{"cache_levels"} || ($cpus{$i}->{"cache_levels"} < $level)) {
				$cpus{$i}->{"cache_levels"} = $level;
			}
		}
		next if (! $curcache);

		if ($curcache eq "u") {
			$cpus{$i}->{$cl} = $size;
		} elsif (exists $cpus{$i}->{$cl}) {
			$cpus{$i}->{$cl} .= "/$size$curcache";
		} else {
			$cpus{$i}->{$cl} = "$size$curcache";
		}
	}
}

# now to grab the total amount of memory in the system
open(FILE, "< $systemmeminfofile") || die("can't open system memory info file: $systemmeminfofile");
while (<FILE>) {
	if ($_ =~ /^MemTotal:\s+(\d+)\skB/) {
		$total_kb_memory = $1;
		# kludge for systems without the $sys_dev_nodepath directory
		if ($nodecount == 1 && $has_topology == 0) {
			$node_mem_size[0] = $total_kb_memory * 1024;
		}
	}
}
close (FILE);

# now grab per-node memory information
# careful - we're using a different definition of 'node' than linux.
# we want the memory per-blade.
#
# this is done in a convoluted way:
#   1) get a mapping of (linux) nodes -> cpus (%sys_nodes_to_cpus)
#   2) get a mapping of blades -> cpus (%blades_to_cpus)
#   3) use %sys_nodes_to_cpus, and %blades_to_cpus to determine
#      the blade->node associations (%blades_to_nodes)
#   4) foreach blade
#        foreach node (associated with the blade)
#          blade_mem += node_mem

open SYS_NODES, "cd $sys_dev_nodepath; ls -d node* 2>/dev/null |"
  or die "failed to list nodes $!";
while (<SYS_NODES>) {
	chomp;
	my $sys_node = $_;
	# use a hash to temporarily hold cpu list - makes if fast to
	# check for duplicate entries (which would be a bug)
	my %tmp = ();
	my $cmd = "cd $sys_dev_nodepath/$sys_node; ".
	          "ls -d cpu[0-9]* 2>/dev/null";
	open SYS_CPUS, "$cmd |" or die "failed to list nodes $!";
	while (<SYS_CPUS>) {
		chomp;
		die if (!/cpu(\d*)/);
		my $sys_cpu = $1;
		# let's be paranoid
		die "cpu $sys_cpu listed twice for node $sys_node"
		  if (exists($tmp{$sys_cpu}));
		$tmp{$sys_cpu} = 1;
	}
	close(SYS_CPUS);
	my @sys_cpus = ();
	push @sys_cpus, sort numerically keys(%tmp);
	$sys_nodes_to_cpus{$sys_node} = \@sys_cpus;
}
close(SYS_NODES);

foreach my $cpu (sort numerically keys(%cpus)) {
	my $blade = $cpus{$cpu}->{blade};
	if (!defined($blades_to_cpus{$blade})) {
		$blades_to_cpus{$blade} = [];
	}
	my @tmp = @{$blades_to_cpus{$blade}};
	push @tmp, $cpu;
	$blades_to_cpus{$blade} = \@tmp;
}

foreach my $blade (keys(%blades_to_cpus)) {
	my @blade_cpus = @{$blades_to_cpus{$blade}};
	my %tmp = ();
	foreach my $node (keys(%sys_nodes_to_cpus)) {
		my @node_cpus = @{$sys_nodes_to_cpus{$node}};
		ND: foreach my $ncpu (@node_cpus) {
			foreach my $bcpu (@blade_cpus) {
				if ($ncpu == $bcpu) {
					$tmp{$node} = 1;
					last ND;
				}
			}
		}
	}
	my @bnodes = keys(%tmp);
	$blades_to_nodes{$blade} = \@bnodes;
}

for (my $i = 0; $i < $nodecount; $i++) {
	# we assume memory can only exist in nodes of class "node"
	if ($node_class[$i] eq "node") {
		my $tmp_total = 0;
		if ($has_topology) {
			foreach my $node (@{$blades_to_nodes{$node_id[$i]}}) {
				if ( -e "${sys_dev_nodepath}/$node/meminfo") {
					open(FILE, "< ${sys_dev_nodepath}/$node/meminfo") ||
					    die("can't open node memory info file: ${sys_dev_nodepath}/$node");
					while (<FILE>) {
						if ($_ =~ /.*?MemTotal:\s*(\d+) kB.*/) {
							$tmp_total += $1;
						}
					}
					close (FILE);
				}
			}
		} else {
			my $node = $node_id[$i];
			my $path = $sys_dev_nodepath . "/node" . $node . "/meminfo";
			if ( -e $path) {
				open(FILE, "< $path") || die("can't open file: $path");
				while (<FILE>) {
					if ($_ =~ /.*?MemTotal:\s*(\d+) kB.*/) {
						$tmp_total += $1;
					}
				}
				close (FILE);
			}
		}

		push @node_mem_size, $tmp_total * 1024;
	} else {
		push @node_mem_size, 0;
	}
}

#################### Output Information #######################

get_mic_node() if $mode_cop;

if ($unexpected_count > 0) {
	if ($unexpected_findings > 0) {
		for (my $i = 0; $i < $unexpected_count; $i++) {
			print $unexpected[$i];
		}
	} else {
		print "Unexpected information found and not parsed.\n";
		print "Machine may contain hardware that topology does not know about.\n";
		print "Use -check option to list that information.\n\n";
	}
}

my $s = "";
# print System Summary
if ($mode_summ) {
	my $sys_label = get_contents($product_file);
	chomp $sys_label;

	if ($verbose) {
		my $prod_number = $sys_type + $uv3k + $mc990x + $hawks2;
		my $prod_name = $sys_types[ $prod_number ];
		$s = " (hub:" . $hub_type . "[" . $hub_name . "]; ";
		$s .= "sys:" . $prod_number . "[" . $prod_name . "]" . ")";
	}

	print "System type: $sys_label$s\n";
	print "System name: $sys_name\n";
	print "Serial number: $sys_serial_number\n";
	print "Partition number: $sys_partition_id\n" if ($has_topology);

	# print out number of racks
	if ($has_topology) {
		my $rack_count = 0;
		my $last_rack = -1;
		foreach my $hubnum (sort keys (%hub_list)) {
			if ($hubnum =~ /r(\d\d\d)i\d\db\d\d/) {
				$rack_count++ if $last_rack != $1;
				$last_rack = $1;
			}
		}
		$s = "s"; $s = "" if $rack_count == 1;
		printf "%8d Rack%s\n", $rack_count, $s;
	}

	# print out number of blades or chassis
	if ($hub_type <= UV2) {
		my $bladecount = $nodecount + $missing_sockets;
		$bladecount /= 2 if $hub_type == UV1;
		$s = "s"; $s = "" if ($bladecount == 1);
		printf "%8d Blade%s\n", $bladecount, $s;
	} else {
		my $chassiscount = $nodecount / 4;
		printf "%8d Chassis\n", $chassiscount;
	}

	# print out number of routers
	if ($routercount > 0 || $verbose) {
		$s = "s"; $s = "" if ($routercount == 1);
		printf "%8d Router%s\n", $routercount, $s;
	}

	# print out number of cpus
	my $extra = "";
	get_online_cpus();
	$extra = " (online: " . $online_cpus . ")" if $online_cpus ne "";
	$s = "s"; $s = "" if ($cpucount == 1);
	printf "%8d CPU%s%s\n", $cpucount, $s, $extra;

	# print out number of nodes
	$s = "s"; $s = "" if ($nodecount == 1);
	printf "%8d Node%s\n", $nodecount, $s;

	# print out number of unpopulated sockets (hublets)
	if ($missing_sockets > 0 || $verbose) {
		$s = "s"; $s = "" if ($missing_sockets == 1);
		printf "%8d Unpopulated Socket%s\n", $missing_sockets, $s;
	}

	# Get persistent memory total
	my $sys_pmem_total = sys_pmem_total();
	my $sram_total = $total_kb_memory * 1024;
	my $mem_total = $sys_pmem_total + $sram_total;
	my $size;
	my $scale;

	# print out memory totals
	($size, $scale) = get_order($mem_total, 100000);
	printf "%8d %s Memory Total\n", $size, $scale;
	if ($sys_pmem_total) {
		($size, $scale) = get_order($sram_total, 100000);
		printf "%8d %s System RAM Total\n", $size, $scale;
		($size, $scale) = get_order($sys_pmem_total, 100000);
		printf "%8d %s Persistent Memory Total\n", $size, $scale;
	}

	# get system addresses
	sys_addresses();

	# print I/O Base count (usually only 1 is enabled)
	if ($io_bases > 0 || $verbose) {
		$s = "s"; $s = "" if ($io_bases == 1);
		printf "%8d BASE I/O Riser%s\n", $io_bases, $s if $hub_type <= UV3;
		printf "%8d BASE I/O Card%s\n", $io_bases, $s if $hub_type >= UV4;
	}
	# print out i/o riser & PCIe slot count for appropriate UV arches
	if ($hub_type <= UV2) {
		if ($io_risers > 0 || $verbose) {
			$s = "s"; $s = "" if ($io_risers == 1);
			printf "%8d I/O Riser%s\n", $io_risers, $s;
		}
		if ($pcie_slots > 0 || $verbose) {
			$s = "s"; $s = "" if ($pcie_slots == 1);
			printf "%8d PCIe Slot%s\n", $pcie_slots, $s;
		}
	}
	if ($pcie_cards > 0 || $verbose) {
		$s = "s"; $s = "" if ($pcie_cards == 1);
		printf "%8d PCIe Card%s\n", $pcie_cards, $s;
	}

	# print out number of co-processors
	if ($copcount > 0 || $verbose) {
		$s = "s"; $s = "" if ($copcount == 1);
		printf "%8d Co-processor%s\n", $copcount, $s;
	}

	# print out number of gp gpus
	if ($gpgpucount > 0 || $verbose) {
		$s = "s"; $s = "" if ($gpgpucount == 1);
		printf "%8d GP GPU%s\n", $gpgpucount, $s;
	}

	# print out number of fibre channel controllers
	if ($fibcount > 0 || $verbose) {
		$s = "s"; $s = "" if ($fibcount == 1);
		printf "%8d Fibre Channel Controller%s\n", $fibcount, $s;
	}

	# print out number of infiniband controllers
	if ($ibcount > 0 || $verbose) {
		$s = "s"; $s = "" if ($ibcount == 1);
		printf "%8d Infiniband Controller%s\n", $ibcount, $s;
	}

	# print out number of network controllers
	$s = "s"; $s = "" if ($netcount == 1);
	printf "%8d Network Controller%s\n", $netcount, $s;

	# print out number of SCSI Storage controllers
	if ($scsicount > 0 || $verbose) {
		$s = "s"; $s = "" if ($scsicount == 1);
		printf "%8d SCSI Storage Controller%s\n", $scsicount, $s;
	}

	# print out number of SATA Storage controllers
	if ($satacount > 0 || $verbose) {
		$s = "s"; $s = "" if ($satacount == 1);
		printf "%8d SATA Storage Controller%s\n", $satacount, $s;
	}

	# print out number of usb controllers
	$s = "s"; $s = "" if ($usbcount == 1);
	printf "%8d USB Controller%s\n", $usbcount, $s;

	# print out number of vga gpus
	if ($vgacount > 0 || $verbose) {
		$s = "s"; $s = "" if ($vgacount == 1);
		printf "%8d VGA GPU%s\n", $vgacount, $s;
	}

	# print out the number of RAID devices
	if ($raidcount > 0 || $verbose) {
		$s = "s"; $s = "" if ($raidcount == 1);
		printf "%8d RAID Controller%s\n", $raidcount, $s;
	}

	# print out the number of Non-Volatile; memory controller devices
	if ($nvmccount > 0 || $verbose) {
		$s = "s"; $s = "" if ($nvmccount == 1);
		printf "%8d Non-Volatile Memory Controller%s\n", $nvmccount, $s;
	}
}

sub get_order
{
	my ($size, $scale) = @_;
	printf("go: size:0x%x scale:%d\n", $size, $scale) if $debug > 3;
	my $order = -1;
	my @suffixes = qw(KB MB GB TB PB EB);	# S/B Kib Mib, etc.  needs target adjustments

	while ($size > $scale) {
		$size /= 1024;
		$order++;
	}
	$size = sprintf "%i", $size;

	my $suffix = "  ";
	$suffix = $suffixes[$order] if $order >= 0;
	print "go: size:$size order:$order scale:$scale suffix:$suffix\n" if $debug > 3;

	return ($size, $suffix);
}

my $node_fmt1  = " %3d %13s   %04x  %3d";
my $node_fmt1s = " %3s %13s   %4s  %3s";
my $node_fmt2 = " %7d %s%s%15s%2s\n";

# print out Memory ranges
my $last_mems_index;
sub print_mems
{
	my ($nid, $loc, $nasid, $numcpus, $physaddr) = @_;
	my $range = $node_ranges[$nid];
	my @addrs = split /,/, $range;
	print "pm: node:$nid range:$range\npm: addrs:    $addrs[$#addrs]\n" if $debug > 2;

	my $lphysaddr = $1 if ($addrs[$#addrs] =~ /<(\S+)/);
	print "pm: physaddr:$physaddr lphysaddr:$lphysaddr\n" if $debug > 2;

	my $info1;
	if ($headers) {
		$info1 = sprintf $node_fmt1s, ".", ".", ".", ".";
	} else {
		$info1 = sprintf $node_fmt1, $nid, $loc, $nasid, $numcpus;
	}
	printf "%s\n", "".$info1 if $debug > 2;

	$last_mems_index = 0 if $nid == 0;
	my $i;
	for ($i = $last_mems_index; $i <= $mems_map; $i++) {
		my ($st, $end, $len, $type) = split(',', $mems_map[$i]);
		chomp $type;
		print "pm: st $st end $end len $len type $type\n" if $debug > 2;
		my $s = hex($st);
		my $e = hex($end);
		print "pm: s  $st lphysaddr:$lphysaddr\n" if $debug > 2;
		last if $s >= hex($lphysaddr);
		print "pm: e  $st physaddr: $lphysaddr\n" if $debug > 2;
		next if $e < hex($physaddr);
		my ($size, $scale) = get_order(hex($len), 10000);
		my $stype;
		$stype = "System RAM" if $type eq "SR";
		$stype = "Persistent Mem" if $type eq "PM";

		my $info2 = sprintf("%7d %s  0x%012x-0x%012x %s",
			$size, $scale, $s, $e, $stype);

		# print resultant composite
		printf("%s %s\n", $info1, $info2);
	}
	$last_mems_index = $i;
}

# print out Node table
sub print_node_table
{
	print "pnt: print_node_table()\n" if $debug > 2;

	# Grab persistent memory ranges
	sys_pmem_total();

	if ($headers) {
		my $h = "";
		my $d = "";
		if ($verbose) {
			if ($hub_type == UV1) {
				$h = "    Phys Address     Nodes  CPU List";
				$d = "  ---------------------------------";
			} elsif ($hub_type >= UV2) {
				if ($pmem_count) {
					$h = "  Phys Addresses  CPUs/Memory Type";
					$d = "  -------------- ------------------";
				} else {
					$h = "    Phys Address   CPU List";
					$d = "  --------------------------";
				}
			}
		}
		my $h0 = " ";
		my $d0 = " ";
		if ($hub_type >= UV2) {
			$h0 = "";
			$d0 = "";
		}
		if ($has_topology) {
			printf "\n Node   %sLocation    NASID  CPUS    Memory%s\n",
				$h0, $h;
			printf   "---------%s--------------------------------%s\n",
				$d0, $d;
		} else {
			printf "\n Index     ID   CPUS  Memory\n";
			printf   "------ ------  ----- ---------\n";
		}
	}
	for (my $i = 0; $i < $nodecount; $i++) {
		my $numcpus = 0;
		my $cpulist = "";

		my $physaddr = "";
		$physaddr = "  " . get_phys_addr($i);
		print "pnt: physaddr $physaddr\n" if $debug > 2;

		for (my $j = 0; $j < $cpucount; $j++) {
			$numcpus++ if ($cpus{$j}->{"blade"} eq $node_id[$i]);
		}
		if ($verbose) {
			my $cpus;
			if ($hub_type == UV1) {
				my $n1 = $i * 2;
				my $n2 = $n1 + 1;
				my $nds = $n1 . "," . $n2;
				$cpus = get_cpulist($i * 2);
				$cpulist = sprintf "  %7s %9s", $i, $cpus;
			} else { # UV2 and up, non-UV
				$cpus = get_cpulist($i);
				$cpulist = sprintf " %10s", $cpus;
			}
		}

		my $nid = $i;
		my $loc = $bmc_id[$i];
		print "pnt: nid:$nid loc:$loc physaddr:$physaddr cpulist:'$cpulist'\n" if $debug > 1;

		# add sys ram + pmem for node total
	#	my $inaddr = $physaddr;
	#	$inaddr =~ s/^\s*//;
	#	my $pmem_node_tot = sys_pmem_node_total($nid, hex $inaddr);
		my $pmem_node_tot = sys_pmem_node_total($nid);
		my $node_tot_gb = $pmem_node_tot / 1024 / 1024;
		print "pnt: sys_pmem_node_tot:$pmem_node_tot/$node_tot_gb\n" if $debug > 1;
		my ($total_memsize, $total_memscale) =
			get_order($node_mem_size[$i] + $pmem_node_tot, 10000);
		print "pnt: memsize:$total_memsize memscale:$total_memscale\n"
			if $debug > 1;
		if ($has_topology) {
			if (not $verbose) {
				printf $node_fmt1 . $node_fmt2,
					$nid, $loc, $node_nasid[$nid], $numcpus,
					$total_memsize, $total_memscale;
			} else {
			#	$node_fmt2 =~ s/\n/ Total\n/;
				printf $node_fmt1 . $node_fmt2,
					$nid, $loc, $node_nasid[$nid], $numcpus,
					$total_memsize, $total_memscale,
					$physaddr, $cpulist,
					$pmem_count == 0? "": " Total";
				print_mems($nid, $loc, $node_nasid[$nid], $numcpus, $physaddr)
					if $verbose and $pmem_count;
			}

		} elsif ($verbose) {
			# physaddr and cpulist only if verbose
			printf "%6d %6d %5d  %5d %s %s %s\n",
			       $nid, $loc, $numcpus, $total_memsize, $total_memscale,
			       $physaddr, $cpulist;
		}
	}
}
#(s/b moved to a more pertinent location)
print_node_table if $mode_node;

# gather CPU info
if ($mode_cpu) {
	# first pass - calculate the width of columns
	my %cpucols;
	my %cpuhdrs;
	my @cpuco;
	if ($has_topology) {
		%cpuhdrs = ( cpu => "CPU",
		             blade => "Location",
		             bmcid => "Location",
		             physid => "PhysID",
		             coreid => "CoreID",
		             apicid => "APIC-ID",
		             family => "Family",
		             model => "Model",
		             speed => "Speed",
		             l1 => "L1(KiB)",
		             l2 => "L2(KiB)",
		             l3 => "L3(KiB)" );
		@cpuco = qw(cpu bmcid physid coreid apicid family model speed l1 l2 l3);
	} else {
		# no apicid, and the location (and PhysID) is a node
		%cpuhdrs = (cpu => "CPU",
		            blade => "Node",
		            coreid => "CoreID",
		            family => "Family",
		            model => "Model",
		            speed => "Speed",
		            l1 => "L1(KiB)",
		            l2 => "L2(KiB)",
		            l3 => "L3(KiB)" );
		@cpuco = qw(cpu blade coreid family model speed l1 l2 l3);
	}

	foreach my $i (keys %cpuhdrs) {
		$cpucols{$i} = length $cpuhdrs{$i};
	}

	foreach my $i (sort (keys %cpus)) {
		if ($cpucols{"cpu"} < length $i) {
			$cpucols{"cpu"} = length $i;
		}

		foreach my $id (qw(bmcid physid coreid apicid family model speed)) {
			if ($cpucols{$id} < length $cpus{$i}->{$id}) {
				$cpucols{$id} = length $cpus{$i}->{$id};
			}
		}

		if (exists $cpus{$i}->{"cache_levels"}) {
			for (my $l=1; $l <= $cpus{$i}->{"cache_levels"}; $l++) {
				my $cl = "l$l";
				if (exists $cpus{$i}->{$cl}) {
					if ($cpucols{$cl} < length $cpus{$i}->{$cl}) {
						$cpucols{$cl} = length $cpus{$i}->{$cl};
					}
				}
			}
		}
	}

	my $extra = 0;
	my $len = 0;
	print "\n" if $headers;
	foreach my $i (@cpuco) {
		printf ("%*s", $cpucols{$i}+$extra, $cpuhdrs{$i}) if $headers;
		$len += $cpucols{$i} + $extra;
		$extra = 1;
	}
	if ($headers) {
		print "\n"; print "-" x $len; print "\n";
	}

	# print CPU table
	foreach my $i (sort {$a <=> $b} (keys %cpus)) {
		printf ("%*d", $cpucols{"cpu"}, $i);

		if ($has_topology) {
			foreach my $id (qw(bmcid physid coreid apicid family model speed)) {
				printf ("%*s", $cpucols{$id}+1, $cpus{$i}->{$id});
			}
		} else {
			foreach my $id (qw(blade coreid family model speed)) {
				printf ("%*s", $cpucols{$id}+1, $cpus{$i}->{$id});
			}
		}

		if (exists $cpus{$i}->{"cache_levels"}) {
			for (my $l=1; $l <= $cpus{$i}->{"cache_levels"}; $l++) {
				my $cl = "l$l";
				my $csz = (exists $cpus{$i}->{$cl}) ? $cpus{$i}->{$cl} : "";
				printf ("%*s", $cpucols{$cl}+1, $csz);
			}
		}
		print "\n";
	}
}

# print out router table
if ($mode_rtr && $routercount > 0) {
	if ($headers) {
		print "\nRouter         ID      Class\n";
		print "----------------------------\n";
	}
	for (my $i = 0; $i < $routercount; $i++) {
		printf "%6d %10s %10s\n", $i, $router_id[$i], $router_class[$i];
	}
}

$arg_nomga = 1 if $mode_gfx_only and ($gpgpucount or $vgacount > 1);
$arg_nox = 1 unless ($gpgpucount || $vgacount > 1 || length($mgadevice) || $displaycount);
#    ($vgacount == 1 && $displaycount == 1));
printf "GPUS: gpgpucount:%d vgacount:%d displaycount:%d mgadevice:%x mgadevid:%x arg_nox:%d\n",
       $gpgpucount, $vgacount, $displaycount, $mgadevice, $mgadevid, $arg_nox if $debug > 1;

my $dashes = "---------------------------------";
my $cpuwidth = 19;
$cpuwidth = 17 if $cpucount < 2000;
$cpuwidth = 15 if $cpucount < 1000;
my $half_cpuwidth = $cpuwidth / 2;

my $screen_width = 0;
foreach my $disp (keys (%displays)) {
	my $width = length($disp);
	$screen_width = $width if $screen_width < $width;
}
$screen_width += 2;

# print out I/O or Xorg.conf table
if ($mode_cop || $mode_dsk || $mode_gfx || $mode_net || $mode_nvmc) {
	if ($has_topology) {
		die "Error: no I/O risers found\n" if ($risercount == 0);
	}
	if ($arg_xorg) {
		print_x();
	} else {
		print_io();
	}
}

if ($footnotes_enabled) {
	print "\n"; # give the footnotes some space
	print_footnotes();
}

# Clean up any temporary files
system("rm -rf $cache_base");
exit 0;

#################### Various Subroutines ####################

sub bynumber { $a <=> $b }

sub numerically { $a <=> $b };

sub read_file
{
	my $fname = shift;
	print "fname: $fname\n" if $debug > 1;
	open(FILE, "< $fname") || die "can't open file: $fname";
	my $data = readline(FILE);
	close(FILE);
	chop $data;
	print "data: $data\n" if $debug > 1;
	return $data;
}

sub cat
{
	my $file = shift;
	$file = "cat ". $file . " |";
	open FILE, $file;
	my $data;
	while (<FILE>) {
		chomp;
		$data = $_;
		last;
	}
	close FILE;
	return $data;
}

sub return_systype
{
	my $sys_type = shift;
	$sys_type += $uv3k;
	$sys_type += $mc990x;
	$sys_type += $hawks2;
	if ($verbose) {
		print "$sys_types_short[$sys_type] $hub_name\n";
	} else {
		print "$sys_types_short[$sys_type]\n";
	}
	exit 0;
}

sub get_sysfs_dir
{
	my $devname = shift;
	my $sname = "$toporoot/sys/bus/pci/devices/" . $devname;
	my @sname = split(/\//, $sname);
	my $lname = readlink($sname);
	my @lname = split(/\//, $lname);
	print "sname $sname\nlname $lname\n" if $debug > 1;

	# reduce symlink
	pop(@sname);
	while (@lname) {
		my $item = shift @lname;
		next if $item eq "." or $item eq "";
		if ($item eq "..") {
			pop @sname if @sname > 1;
			next;
		}
		push(@sname, $item);
	}

	my $dname = join("/", @sname);
	print "dname $dname\n" if $debug > 1;
	return $dname;
}

sub sys_pmem_node_total
{
	my $nid = shift;
	printf "\nspnt: sys_pmem_node_total(%d)\n", $nid if $debug > 2;
##	print "spnt: pmem_count == 0\n" if not $pmem_count and $debug > 2;
	return 0 if not $pmem_count;
	get_node_ranges();
	my $range = $node_ranges[$nid];
	my @addrs = split /,/, $range;
	print "spnt: node $nid addrs '@addrs' ($#addrs)\n" if $debug > 1;
	sys_mems_ranges();

	my $physaddr  = $1 if ($addrs[0] =~ /(\S+)-/);
	my $lphysaddr = $1 if ($addrs[$#addrs] =~ /<(\S+)/);
	printf "spnt: physaddr:0x%x lphysaddr:0x%x\n", hex $physaddr, hex $lphysaddr if $debug > 2;

	my $pmem_node_tot = 0;
	my @pmem_entries = @mems_map;

	if ($debug > 2) {
		my @prt_pmem_entries = @pmem_entries;
		print "\n--- selected mems_map entries ---\n";
		for (my $i = 0; $i <= $mems_map; $i++) {
			my $prt_entry = shift @prt_pmem_entries; chomp $prt_entry;
			my ($st, $end, $len, $type) = split(',', $prt_entry);
			my $s  = "-"; $s  = "*" if (hex $st >= hex $physaddr and hex $end <= hex $lphysaddr);
			my $se = "-"; $se = "+" if (hex $st)  >= (hex $physaddr);
			my $le = "-"; $le = "+" if (hex $end) <= (hex $lphysaddr);
			printf "spnt: st:0x%x phys:0x%x end:0x%x lphys:0x%x\n", hex $st, hex $physaddr, hex $end, hex $lphysaddr;
			print "spnt: $prt_entry$s (st:$st:$physaddr($se),end:$end:$lphysaddr($le))\n";
		}
		print "\n";
	}
	for (my $i = 0; $i <= $mems_map; $i++) {
		my ($st, $end, $len, $type) = split(',', shift @pmem_entries);
		chomp $type;
		print "spnt: $i st:$st end:$end len:$len type:$type\n" if $debug > 2;
		next if $type ne "PM";

		my $s = hex $st;
		my $e = hex $end;
		my $se = 0; $se = 1 if $s >= hex $lphysaddr;
		my $ee = 0; $ee = 1 if $e <= hex $physaddr;

		my $msg1 = sprintf "\nspnt: strt:0x%016x(%d) end:0x%016x(%d)\n", $s, $se, $e, $ee;
		my $msg2 = sprintf "spnt: lphy:0x%016x    phy:0x%016x\n", hex $lphysaddr, hex $physaddr;

	#	print "spnt: st $st($se) end $end($ee) len $len type $type\n" if $debug > 2;
		print "$msg1","$msg2" if $debug > 2;
		last if $se;
		next if $ee;
	#	last if ($s >= hex $lphysaddr);
	#	next if ($e <= hex $physaddr);

	#	printf("spnt: st:0x%x lphy:0x%x(%d) end:0x%x phy:0x%x(%d)\n",
	#		$s, $lphysaddr, $se, $e, $physaddr, $ee) if $debug > 2;
		$pmem_node_tot += hex $len;
		my $pmem_gb = $pmem_node_tot / 1024 / 1024 / 1024;
		printf("spnt: len %s pmem_node_tot 0x%x(%d)\n", $len, $pmem_node_tot, $pmem_gb) if $debug > 2;
	}
	printf("spnt: pmem_node_tot 0x%x(%d)\n", $pmem_node_tot, $pmem_node_tot/1024/1024/1024) if $debug > 2;
	return $pmem_node_tot;
}

sub sys_pmem_total
{
	print "\nspt: sys_pmem_total(pmem_count:$pmem_count)\n" if $debug > 2;
	return $pmem_count if $pmem_count;
	sys_mems_ranges();
	my $pmem_tot = 0;
	my @pmem_entries = @mems_map;
	my $pmem_gb;

	for (my $i = 0; $i <= $mems_map; $i++) {
		my ($st, $end, $len, $type) = split(',', shift @pmem_entries);
		chomp $type;
		print "spt: st:$st end:$end len:$len type:$type\n" if $debug > 2;
		next if $type ne "PM";
		$pmem_tot += hex $len;
		$pmem_count++;
		$pmem_gb = $pmem_tot / 1024 / 1024 / 1024;
		printf("spt: %s pmem_tot 0x%x(%d)\n", $len, $pmem_tot, $pmem_gb) if $debug > 2;
	}
	print "spt: pmem_count:$pmem_count pmem_gb:$pmem_gb\n" if $debug > 2;
	return $pmem_tot;
}

# Walk EFI memmap to find System RAM and Persistent Memory physical
# address chunks.
my $smr_printed = 0;
sub sys_mems_ranges
{
	print "smr: sys_mems_ranges(mems_map:$mems_map)\n" if $debug > 2;
	if ($mems_map) {
		if (!$smr_printed) {
			print "smr: mems_map($mems_map) cached\n"
				if $debug > 2;
			$smr_printed = 1;
		return;
		}
	}
	return if sys_mems_cache_read();

	my @memmap = ();
	my $mp = "$toporoot/sys/firmware/memmap";

	open(FILE, "ls $mp | sort -n | \
		while read n; \
			do grep -q -e \"Persistent Memory\" -e \"System RAM\" $mp/\$n/type && \
				cat $mp/\$n/{start,end,type}; \
		done |");
	@memmap = readline(FILE);
	close(FILE);

	# deterine first if there are PMEM's present
	for (my $i = 0; $i <= $#memmap; $i += 3 ) {
		$pmem_count++ if $memmap[$i + 2] eq "Persistent Memory\n";
	}
	print "smr: pmem_count == 0\n" if not $pmem_count and $debug > 2;
	return 0 if not $pmem_count;

	# there is at least one, so get a collection of all memory types
	my $bsM1 = get_block_size_bytes() - 1;
	my $first = hex("0x00007fffffff");
	printf("bsM1:0x%010x\n", $bsM1) if $debug > 2;

	for (my $i = 0; $i <= $#memmap; $i += 3 ) {
		my $start = hex($memmap[$i]); chomp $start;
		my $end   = hex($memmap[$i + 1]); chomp $end;
		my $type  = $memmap[$i + 2]; chomp $type;
		my $mem;
		   $mem = "PM" if $type eq "Persistent Memory";
		   $mem = "SR" if $type eq "System RAM";
		my $nbndry = $start & $bsM1;

		my $skip;
		if ($start == 0) {
			$end = $first;
			$nbndry = 0;
			$skip = 1;
		} elsif ($skip and $start <= $first) {
			next;
		}
		printf("smr: start:%012x nbndry:%d end:%012x type:%s mem:%s\n",
			$start, !!$nbndry, $end, $type, $mem) if $debug > 2;

		next if $nbndry;
	#	my $len = sprintf("0x%x", hex($end) + 1 - hex($start));
	#	my $range = sprintf("0x%016x", hex($start))
	#	    . "," . sprintf("0x%016x", hex($end) + 1)
	#	    . "," . sprintf("0x%016x", hex($len))
	#	    . "," . sprintf("%s", $mem);

		my $len = sprintf("0x%x", $end + 1 - $start);
		my $range = sprintf("0x%016x", $start)
		    . "," . sprintf("0x%016x", $end + 1)
		    . "," . sprintf("0x%016x", hex($len))
		    . "," . sprintf("%s", $mem);

		printf("smr: start:%012x end:%012x len:%012x range:%s\n",
			$start, $end, $len, $range) if $debug > 2;
		push @mems_map, $range . "\n";
		$skip = 0 if $skip;
	}
	$mems_map = $#mems_map;
	print "\nsmr: mems_map($mems_map)\n @mems_map\n" if $debug > 1;
	sys_mems_cache_write();
}

# Write mems_map info to sys_mems cache file.
sub sys_mems_cache_write
{
	if (-r $mems_map_cache_file) {
		print "sys_mems_cache_write: $mems_map_cache_file file already present\n"
			if $debug > 1;
		return;
	}
	print "smcw: sys_mems_cache_write($mems_map,$#mems_map)\n" if $debug > 1;
	open my $cf, ">$mems_map_cache_file"
		or die "cannot create $mems_map_cache_file\n";
	print $cf "$mems_map\n@mems_map\n";
	close $cf;
}

# Read mems_map info from sys_mems cache file.
my $smcr_printed = 0;
sub sys_mems_cache_read
{
	if (! -r $mems_map_cache_file) {
		print "sys_mems_cache_read: no $mems_map_cache_file file found\n"
			if $debug > 1;
		return;
	}

	open my $cf, "<$mems_map_cache_file" or die;
	$mems_map = readline $cf;
	chomp $mems_map;
	print "smcr: sys_mems_cache_read($mems_map)\n" if $debug > 1;
	for (my $i = 0; $i <= $mems_map; $i++) {
		$mems_map[$i] = readline $cf;
		$mems_map[$i] =~ s/ //g;
		print "smcr: i:$i $mems_map[$i]" if $debug > 2 and ($smcr_printed == 0);
	}
	close $cf;
	if ($smcr_printed == 0) {
		print "\nsmcr: mems_map($mems_map)[cached]\n @mems_map\n" if $debug > 1;
		$smcr_printed = 1;
	}
	return $mems_map;
}

sub sys_addresses
{
	my @memmap = ();
	my $mp = "$toporoot/sys/firmware/memmap";

	open(FILE, "ls $mp | sort -n | while read n; do grep -q \"System RAM\" $mp/\$n/type && cat $mp/\$n/{start,end}; done |");
	@memmap = readline(FILE);
	close(FILE);

	my $n = $#memmap;

	if ($memmap[0] =~ /0x([[:xdigit:]]+)/) {
		$base_address = hex("$1");
	}
	if ($memmap[$n] =~ /0x([[:xdigit:]]+)/) {
		$last_address = hex("$1") + 1;
	}
	if ($debug) {
		print "total entries: $n\n";
		print "base address: $base_address: $memmap[0]";
		print "last address: $last_address: $memmap[$n]";
	}
}

# Given a list of node IDs, return the number of unique IDs before the # sign.
# This is useful for counting the number of physical C-Bricks, TIO nodes...

#XXX: unused
sub unique_id_count
{
	my %unique_ids;
	foreach (@_) {
		next unless (/^(.+)#/);
		$unique_ids{$1} = 1;
	}
	return scalar(keys %unique_ids);
}

sub get_online_cpus
{
	return $online_cpus if $online_cpus ne "";
	if (open(DATA, "< $sys_dev_cpupath/online")) {
		$online_cpus = readline(DATA);
		close(DATA);
		chop $online_cpus;
		print "online_cpus: $online_cpus\n" if $debug;
	}
	return $online_cpus;
}

sub get_cpulist
{
	my $node = shift;
	my $list0 = read_file("$sys_dev_nodepath/node". $node ."/cpulist");
	if ($hub_type == UV1) {
		$node = $node + 1;
		my $list1 = read_file("$sys_dev_nodepath/node". $node ."/cpulist");

		my $list2 = $list0 .":". $list1;
		print "list2: $list2\n" if $debug > 1;

		if ($list2 =~ /(\d+)-(\d+),(\d+)-(\d+):(\d+)-(\d+),(\d+)-(\d+)/) {
			my $list = $1 ."-". $6 .",". $3 ."-". $8;
			return $list;
		}
		if ($list2 =~ /(\d+)-(\d+):(\d+)-(\d+)/) {
			my $list = $1 ."-". $4;
			return $list;
		}
	} else {
		return $list0;
	}
	# else -- add new UV types here XXX
}

sub get_cpuslist
{
	my $node = shift;
	my $cpus = get_cpulist($node);
	my $cpulist = '';
	my $c = '';

	if ($cpus =~ /(\d+)-(\d+),(\d+)-(\d+)/) {
		# (hyperthreaded cpus)
		for (my $cpu = $1; $cpu <= $2; $cpu++) {
			$cpulist .= $c . $cpu;
			$c = ',';
		}
		for (my $cpu = $3; $cpu <= $4; $cpu++) {
			$cpulist .= $c . $cpu;
		}
	} elsif ($cpus =~ /(\d+)-(\d+)/) {
		for (my $cpu = $1; $cpu <= $2; $cpu++) {
			$cpulist .= $c . $cpu;
			$c = ',';
		}
	}
	return $cpulist;
}

sub get_pci_nodes
{
	for (my $i = 0; $i < $nodecount; $i++) {
		my $nid = $node_id[$i];

		if ($i == 0 || exists $risers{$nid}) {
			my $pcibus;
			my $nextpcibus;
			my $nextline = 0;

			if ($i == 0) {
				$pcibus = 0;
			} else {
				$pcibus = $risers{$nid} + 0;
			}

			if ($risercount > 1 and defined $pcibusincrs{$pcibus}) {
				$nextpcibus = $pcibus + $pcibusincrs{$pcibus};
			} else {
				$nextpcibus = $pcibus + 0x100;
			}

			$pci_nodes{$pcibus} = $i;
			$pci_nodes{$pcibus} *= 2 if $hub_type == UV1;

			printf("--- nid %s node %d pcibus %x pci_nodes{%x} = %d\n",
			       $nid, $i * 2, $pcibus, $pcibus, $pci_nodes{$pcibus}) if $debug > 1;
		}
	}
}

sub get_mic_node
{
	get_pci_nodes();
	if ($get_node =~ /(mic:\d+)/) {
		my $micid = $1;
		my $node = 0;
		my $nid = $copnodes{$micid};
		if (!defined $nid) {
			print STDERR "$micid is not present\n";
			exit 1;
		}
		$node = $pci_nodes{$nid};
		print "--- micid $micid nid $nid node $node\n" if $debug > 1;
		print "$node\n";
		exit 0;
	}
	if ($get_cpus =~ /(mic:\d+)/) {
		my $micid = $1;
		my $node = 0;
		my $nid = $copnodes{$micid};
		if (!defined $nid) {
			print STDERR "$micid is not present\n";
			exit 1;
		}
		$node = $pci_nodes{$nid} if defined $nid;
		print "--- micid $micid nid $nid node $node\n" if $debug > 1;
		if ($verbose) {
			my $cpulist = get_cpuslist($node);
			print "--- micid $micid nid $nid node $node cpulist $cpulist\n"
			    if $debug > 1;
			print "$cpulist\n";
			exit 0;
		}
		my $cpus = get_cpulist($node);
		print "--- micid $micid nid $nid node $node cpus $cpus\n" if $debug > 1;
		print "$cpus\n";
		exit 0;
	}
}

sub get_cached_data
{
	my $var = shift;
	my $cache_dir = shift;
	my $fallback_dir = shift;
	my $type = shift;
	my ($final_var, $data);

	# efi vars need */data appended to the var name
	if ($type eq "efi") {
		$final_var = $var . "*/data";
	} elsif ($type eq "dir") {
		$final_var = "/" . $var;	# needs "/"
	} else {
		$final_var = $var;
	}

### (remove)
### print "var:$var cache_dir:$cache_dir fallback_dir:$fallback_dir type:$type final_var:$final_var\n" if $debug > 1;

	# note that we use glob in list context to throw away all but the first returned file
	my ($file, $trash) = glob $cache_dir . $final_var;

	# fall back to the privileged files if there aren't any cached.
	# this won't work for non-root users trying to read efi vars.
	if (! -e $file) {
		print "\tDEBUG: get_cached_data: $file does not exist.  Falling back to $fallback_dir (might not work for non-privileged users!)\n" if $debug > 1;
		($file, $trash) = glob $fallback_dir . $final_var;
	} else {
		print "\tDEBUG: get_cached_data: using cached data at $cache_dir\n" if $debug > 1;
	}

	# check to make sure neither of the globs returned multiple files.  this
	# should never happen.  means that either something went wrong in the uvconfig
	# efivar caching code, or that sysfs is seriously screwy.
	if (defined $trash) {
		print "get_cached_data: WARNING: multiple values defined for $var\n";
	}

	print "\tDEBUG: get_cached_data: file: $file\n" if $debug;

	if (open(DATA, "< $file")) {
		my $line = readline(DATA);
		print "\tDEBUG: get_cached_data: $var data: $line\n" if $debug;
		close(DATA);

		# we have to specify that we're looking for a digit when reading
		# efi vars, because the actual file stores the data in a format that Perl
		# doesn't handle very well (see hexdump <efi_var> vs. cat <efi_var>)
		if ( $type eq "efi" && $line =~ /(\d+)/ ) {
			$data = $1;
		} elsif ( $line =~ /(.+)/ ) {
			$data = $1;
		}

		return $data;
	}

	print "\tDEBUG: get_cached_data: $var data: UNKNOWN\n" if $debug;
	return -1;
}

sub get_phys_addr
{
	my $nid = shift;
	return get_phys_addr_pmem($nid) if $pmem_count;

	my ($memdir, $physidx, $blksize);
	my $nodedir = "$sys_dev_nodepath/node" . $nid;
	my $memcmd = "cd " . $nodedir .
	             "; ls -d memory[0-9]* 2>/dev/null | " .
	             "sed 's/memory//g' | sort -n | head -n1 | ";
	print "gpa: memcmd $memcmd\n" if $debug > 2;
	open MEMDIR, $memcmd;
	while (<MEMDIR>) {
		chomp;
		$memdir = "memory" . $_;
		last;
	}
	close MEMDIR;
	print "gpa: memdir $memdir\n" if $debug > 2;

	my $physidx = cat("$nodedir/$memdir/phys_index");
	print "gpa: physidx $physidx\n" if $debug > 2;

	$block_size_bytes = cat("$toporoot/sys/devices/system/memory/block_size_bytes")
	if ($block_size_bytes == 0) ;
	my $blksize = $block_size_bytes;
	print "gpa: blksize $blksize\n" if $debug > 2;
	my $addr = sprintf ("0x%012x", hex($physidx) * hex($blksize));
	print "gpa: nid $nid memdir $memdir addr $addr\n" if $debug > 1;
	return $addr;
}

## WIP
##	$block_size_bytes =
##	  get_cached_data("block_size_bytes", $memdir_cache_dir, $sys_dev_mempath, "dir")
##	    if $block_size_bytes == 0;
sub get_block_size_bytes
{
	my $blksize = $block_size_bytes;
	if ($blksize) {
		printf("gbsb: block_size_bytes:0x%x(%d) cached\n",
			$blksize, $blksize) if $debug > 2;
		return $blksize;
	}

	my $bfile = "$sys_dev_mempath/block_size_bytes";
	my $hfile = "$toporoot/$install_location/block_size_bytes";
	   $bfile = $hfile if (-r $hfile);
	my $bread = ($block_size_bytes == 0);

	$block_size_bytes = cat($bfile);
	print("gbsb: bfile:$bfile hfile:$hfile bfile:$bfile bread:$bread bsb:$block_size_bytes\n")
		if $debug > 2;

	$blksize = $block_size_bytes = hex cat($bfile)
		if $bread;

	printf("gbsb: block_size_bytes:0x%x(0x%x/%d) from $hfile\n",
		$blksize, $block_size_bytes, $block_size_bytes)
			if $bread and $debug > 2;
	return $blksize;
}

# Get first and last+1 node phys addrs with separate contiguous ranges on each
sub get_mem_limits
{
	my $nid = shift;
	printf("\ngml: get_mem_limits(%d)\n", $nid) if $debug > 2;

	my ($firstidx, $nextidx, $range1 , $range2);
	my @retaddrs = ();
	my $blksize = get_block_size_bytes();

	my $nodedir = "$sys_dev_nodepath/node" . $nid;
	my $memcmd = "cd " . $nodedir .
		"; ls -d memory[0-9]* 2>/dev/null | " .  "sed 's/memory//g' | sort -n | ";
	print "gml: memcmd $memcmd\n" if $debug > 2;

	# Read the sorted list of memory section numbers
	open MEMDIRS, $memcmd;
	while (<MEMDIRS>) {
		chomp;
		my $memdir = "memory" . $_;
		my $physidx = hex(cat("$nodedir/$memdir/phys_index"));
		print "gml: memdir $memdir physidx $physidx nextidx $nextidx\n" if $debug > 3;

		# If first memory section, save it
		if (not defined $firstidx) {
			$firstidx = $physidx;
			$nextidx = $physidx + 1;
			print "gml: firstidx:$firstidx\n" if $debug > 2;
			next;
		}

		# If next is contiguous, continue on
		if ($physidx == $nextidx) {
			$nextidx = $physidx + 1;
			next;
		}

		# If not contiguous it's a new range, save current range
		$range1 = sprintf ("0x%012x", $firstidx * $blksize);
		$range2 = sprintf ("0x%012x", $nextidx  * $blksize);
		if ($debug > 2) {
			printf "gml: firstidx:%4d * 0x%08x = %s\n", $firstidx, $blksize, $range1;
			printf "gml: nextidx: %4d * 0x%08x = %s\n", $nextidx, $blksize, $range2;
		}
		push @retaddrs, $range1.",".$range2;
		print "gml: $range1,$range2 retaddrs:@retaddrs\n" if $debug > 2;

		$firstidx = $physidx;
		$nextidx = $firstidx + 1;
		print "gml: firstidx:$firstidx\n" if $debug > 2;
		next;
	}
	close MEMDIRS;

	# Save last range encountered
	$range1 = sprintf ("0x%012x", $firstidx * $blksize);
	$range2 = sprintf ("0x%012x", $nextidx  * $blksize);
	push @retaddrs, $range1.",".$range2;
	my $rngaddrs = join('+', @retaddrs);
	if ($debug > 2) {
		printf "gml: firstidx:%4d * 0x%08x = %s\n", $firstidx, $blksize, $range1;
		printf "gml: nextidx: %4d * 0x%08x = %s\n", $nextidx, $blksize, $range2;
	##	print  "gml: retaddrs:@retaddrs($#retaddrs)\n";
		print  "gml: rngaddrs:$rngaddrs\n";
	}
	return $rngaddrs;
}

sub push_last_limit
{
	my ($addrs, $lnid) = @_;
	print "pll: push_last_limit($addrs, $lnid)\n" if $debug > 2;
	if ($addrs =~ /(\S+),\S*/) {
		my $addr = "<" . $1;
		my $laddrs = $node_ranges[$lnid];
		my $laddrs = $laddrs . "+" . $addr;
		print "pll: limit addr:$addr laddrs:$laddrs\n" if $debug > 2;
		$node_ranges[$lnid] = $laddrs . "\n";
		print "pll: lnid:$lnid ranges:$node_ranges[$lnid]\n" if $debug > 2;
	}
}

# Walk sysfs nodes/nodeX/memory* sections to discover 1st and last of
# each memory chunk.
my $gnr_printed = 0;
sub get_node_ranges
{
	print "gnr: get_node_ranges()\n" if $debug > 2;
	if ($node_ranges) {
		if (!$gnr_printed) {
			print "gnr: node_ranges($node_ranges)[cached]\n@node_ranges\n"
				if $debug > 2;
			$gnr_printed = 1;
		}
		return;
	}
	return if node_ranges_cache_read();

	my $lnid = -1;

	print "gnr: nodecount:$nodecount\n" if $debug > 2;
	for (my $nid = 0; $nid < $nodecount; $nid++) {
		my $rngaddrs = get_mem_limits($nid);
		print "gnr: node:$nid ranges:$rngaddrs  nid:$nid lnid:$lnid\n"
			if $debug > 2;

		$node_ranges[$nid] = $rngaddrs;
		push_last_limit($rngaddrs, $lnid) if $lnid >= 0;
		$lnid += 1;
	}

	# last limit: 52 bits (for Icelake)
	my $llimit = sprintf "0x%lx,", (1<<52);
	print "gnr: llimit:$llimit (1<<52) lnit:$lnid\n"
		if $debug > 2;
	push_last_limit($llimit, $lnid) if $lnid >= 0;
  	$node_ranges = $nodecount;
	print "\ngnr: node_ranges($node_ranges):\n@node_ranges\n"
		if $debug > 1;
	node_ranges_cache_write();
}

# Write node_ranges info to node_ranges cache file.
sub node_ranges_cache_write
{
	print "nrcw: node_ranges_cache_write\n" if $debug > 1;
	if (-r $node_ranges_cache_file) {
		print "nrcw: $node_ranges_cache_file file already present\n" if $debug > 1;
		return;
	}
	open my $cf, ">$node_ranges_cache_file" or die "cannot create $node_ranges_cache_file\n";
	print $cf "$node_ranges\n@node_ranges\n";
	close $cf;
}

# Read node_ranges info from node_ranges cache file.
my $nrcr_printed = 0;
sub node_ranges_cache_read
{
	print "nrcr: node_ranges_cache_read\n" if $debug > 1;
	if (! -r $node_ranges_cache_file) {
		print "nrcr: no $node_ranges_cache_file file found\n" if $debug > 1;
		return;
	}

	open my $cf, "<$node_ranges_cache_file" or die;
	$node_ranges = readline $cf;
	chomp $node_ranges;
	for (my $i = 0; $i < $node_ranges; $i++) {
		$node_ranges[$i] = readline $cf;
		$node_ranges[$i] =~ s/ //g;
		print "nrcr: i:$i $node_ranges[$i]" if $debug > 2;
	}
	close $cf;
	if ($nrcr_printed == 0) {
		print "\nnrcr: node_ranges($node_ranges)[cached]\n @node_ranges\n" if $debug > 1;
		$nrcr_printed = 1;
	}
	return $node_ranges;
}

sub get_phys_limits
{
	get_node_ranges();
	my $nid = shift;
	my $addrs = $node_ranges[$nid];
	print "gpl: addrs:$addrs\n" if $debug > 1;
	return $addrs;
}

sub get_phys_addr_pmem
{
	my $nid = shift;
	my @addrlimits = split /,/, get_phys_limits($nid);
	print "\ngpap: get_phys_addr($nid) al:@addrlimits\n" if $debug > 2;
	if ($#addrlimits) {
		my $addr = $addrlimits[0];
		print "gpap: addr:$addr\n" if $debug > 2;
		return $addr;
	}

	my ($memdir, $physidx, $blksize);
	my $nodedir = "$sys_dev_nodepath/node" . $nid;
	my $memcmd = "cd " . $nodedir .
	             "; ls -d memory[0-9]* 2>/dev/null | " .
	             "sed 's/memory//g' | sort -n | head -n1 | ";
	print "gpap: memcmd $memcmd\n" if $debug > 2;
	open MEMDIR, $memcmd;
	while (<MEMDIR>) {
		chomp;
		$memdir = "memory" . $_;
		last;
	}
	close MEMDIR;
	print "gpap: memdir $memdir\n" if $debug > 2;

	my $physidx = cat("$nodedir/$memdir/phys_index");
	print "gpap: physidx $physidx\n" if $debug > 2;
	my $blksize = get_block_size_bytes();
	my $addr = sprintf ("0x%012x", hex($physidx) * hex($blksize));
	print "gpap: nid $nid memdir $memdir addr $addr\n" if $debug > 1;
	return $addr;
}

sub get_socket_id
{
	my $nid = shift;
	print "\t--- get_socket_id:$nid hub:$hub_name\n" if $debug > 1;
	return $nid if $hub_type <= UV2;
	if ($nid =~ /(r\d+)(i\d+)b(\d+)h(\d+)/) {
		my $slot = $3 * 2 + $4;
		$slot ^= 1 if $hub_type == UV4;
		my $sktid = sprintf "%s%ss%d", $1, $2, $slot;
		print "\t--- sktid:$sktid\n" if $debug > 1;
		return $sktid;
	}
	print "\t--- sktid:$nid: no conversion\n" if $debug > 1;
	return $nid;
}

sub get_slot_id
{
	my $nid = shift;
	my $skt;
	my $domain = shift;
	my $bus = shift;
	my $pcidb = sprintf "%04X:%02X", $domain, $bus;
	print "--- get_slot_id nid:$nid d:$domain b:$bus db:$pcidb slot:$io_slots{$pcidb}\n" if $debug > 2;
	$skt = get_socket_id($nid);
	print "\t--- skt:$skt\n" if $debug > 2;
	return $nid if $hub_type <= UV2;
	if ($skt =~ /(r\d+i\d+)s(\d+)/) {
		my $loc = $1;
		do {
			my $slot = 0; $slot = $io_slots{$pcidb} if defined $io_slots{$pcidb};
			print "\t--- io_slots{$pcidb} => \'$slot\'\n" if $debug;
			if ($slot =~ /^(\d+)$/) {
				my $slot_id = sprintf "%ss%02d", $loc, $1;
				print "\t--- slot_id:$slot_id\n" if $debug > 1;
				return $slot_id;
			}
			if ($slot =~ /([[:xdigit:]]+:[[:xdigit:]]+)/) {
				$pcidb = $1;
				print "\t--- pcidb:$pcidb\n" if $debug > 1;
			} else {
				my $slot_id = sprintf "%ss00", $loc;
				print "\t--- slot_id:$slot_id\n" if $debug > 1;
				return $slot_id;
			}
		} while (1);
	}
	print "\t--- Error: Slot for Socket $skt Not Found.\n";
	return $skt;
}

sub get_devnode
{
	my $pciaddr = shift;
	print "get_devnode: $pciaddr\n" if $debug > 1;
	my $dname = get_sysfs_dir($pciaddr);
	my $fname = $dname . "/numa_node";
	my $data;
	if (! -e $fname) {
		$data = lookup_node_by_device($pciaddr);
	} else {
		$data = read_file($fname);
	}
	print "get_devnode: $fname => $data\n" if $debug > 1;
	return $data;
}

sub get_nodelist
{
	my $node = shift;
	my $nodelist = $node;
	$nodelist .= ",". $node + 1 if $hub_type == UV1;
	print "get_nodelist: $nodelist\n" if $debug > 1;
	return $nodelist;
}

sub get_monitor
{
	my $screen = shift;
	my $device = shift;
	my $gpu = shift;
	my $monitor;

	print "--- get_monitor $screen $device $gpu\n" if $debug > 1;
	if (defined($usedisplays{$screen})) {
		$monitor = $usedisplays{$screen};
		print "--- monitor $monitor from usedisplays\n" if $debug > 1;
	}

	if (!defined($monitor) || $monitor ne "NONE") {
		$monitor = $terminals{$monitors{$screen}};
		print "--- monitor $monitor from xorg.conf\n" if $debug > 1;
	}
	if (!defined($monitor) || $monitor eq "Unknown") {
		if (defined($subscreens{$device})) {
			my $sub = $subscreens{$device};
			my $ld = $logdisplay{$gpu};
			print "--- logdisplay{$gpu} = $ld\n" if $debug > 1;
			if ($ld ne "NONE") {
				if (index($ld, ":") > 0) {
					my @mons = split(/:/, $ld);
					if (defined($mons[$sub])) {
						$monitor = $mons[$sub];
						print "--- monitor $monitor ($sub) from Xorg.0.log\n" if $debug > 1;
					}
				} elsif ($sub < 1) {
					$monitor = $ld;
					print "--- monitor $monitor (zero) from Xorg.0.log\n" if $debug > 1;
				}
			}
		} else {
			$monitor = $logdisplay{$gpu};
			print "--- monitor $monitor from Xorg.0.log\n" if $debug > 1;
			if ($monitor eq "none") {
				$monitor = "no connected monitors";
			}
			print "--- monitor $monitor (assumed) from Xorg.0.log\n" if $debug > 1;
		}
	}
	return $monitor;
}

sub get_pciid
{
	my $x = shift;
	my $f = $x & 255;

	$x >>= 8;
	my $s = $x & 255;

	$x >>= 8;
	my $b = $x & 255;
	my $d = $x >> 8;

	return ($d, $b, $s, $f);
}

sub get_display
{
	my $device = shift;
	my $subdev = shift;
	my $i = shift;
	my $dev;
	my $screen = "-";
	my $screen_number = -1;
	my $monitor;
	my $xdisplay = "";
	my $disp;

	printf ("--- get_display %x %d %d\n", $device, $subdev, $i) if $debug > 1;
	foreach $disp (sort keys (%displays)) {
		my $devid = $devids{ $displays{ $disp } };
		$dev = $devices{ $devid };
		printf("DISP %s %s %x\n", $disp,$devid,$dev) if $debug > 1;
		if ($dev == $device ||
		   ($dev == 0 && $device eq $mgadevid && $mgadevice eq $devid)) {
			$screen = $disp;
			$screen_number = $screen_numbers{ $screen };
			next if ($assigned{$screen_number} eq "");
			$assigned{$screen_number} = "";
			print "==> screen $screen screen_number $screen_number\n" if $debug > 1;
			last;
		}
	}
	if ($get_node =~ /^:/) {
		print "get_node $get_node screen $screen\n" if $debug;
		if ($get_node eq $screen) {
			my $node = $i; # node index
			if ($hub_type == UV1) {
				$node = $node * 2;
				if ($verbose) {
					printf "%d,%d\n", $node, $node + 1;
				} else {
					printf "%d\n", $node;
				}
			} else {
				printf "%d\n", $node;
			}
			exit 0;
		}
	}

	if ($get_cpus =~ /^:/) {
		print "get_cpus $get_cpus screen $screen\n" if $debug;
		if ($get_cpus eq $screen) {
			my $node = $i; # node index
			if ($verbose) {
				my $cpulist = get_cpuslist($node);
				print "=== screen $screen node $node cpus $cpulist\n"
				  if $debug > 1;
				print "$cpulist\n";
				exit 0;
			}
			my $cpus = get_cpulist($node);
			print "=== screen $screen node $node cpus $cpus\n"
			  if $debug > 1;
			print "$cpus\n";
			exit 0;
		}
	}

	if ($mode_gfx && $verbose) {
		# get monitor and keyboard/mouse
		$monitor = $terminals{
		           $monitors{
		           $devids{
		           $displays{
		           $disp } } } };
	print "--- monitor $monitor\n" if $debug > 1;
	}
	return $screen;
}

#    000000,00000000,00000000,00000000,00000000,00000000,00000000,00000008
#    ffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff
#    000000,00000000,00000000,00000000,00000000,00000000,00000000,00000010
#    000000,00000000,00000000,00000000,00000000,00000000,00000000,00000020

# function to find 1 (yes ONE) bit set
sub get_smp_list
{
	my @smp = split(/,/, shift);
	my $irq = shift;
	my $cpu = 0;
	my $list = "   -";
	my @hd;
	($hd[1], $hd[2], $hd[4], $hd[8]) = (0, 1, 2, 3);

	while (@smp) {
		my $word = splice(@smp, -1, 1);
		last if ($word =~ /.*ffffffff$/);
		if ($word =~ /00000000/) {
			$cpu = $cpu + 32;
			next;
		}

		my @bits = split(//, $word);
		while (@bits) {
			my $digit = splice(@bits, -1, 1);
			if ($digit =~ /([1248])/) {
				$cpu = $cpu + $hd[$1];
				$list = sprintf "%4d", $cpu;
				return $list;
			}
			$cpu = $cpu + 4;
		}
		last;
	}
	return $list;
}

sub get_smp_affinity
{
	my $irq = shift;

	# try first the new smp_affinity_list interface
	my $fname = "$toporoot/proc/irq/" . $irq . "/smp_affinity_list";
	if (open(FILE, "< $fname")) {
		my $smplist = readline(FILE);
		close(FILE);
		print "get_smp_affinity $fname smplist:$smplist\n" if $debug > 1;
		chop $smplist;
		return $smplist;
	}

	# else fall back to finding first bit smp_affinity mask
	$fname = "$toporoot/proc/irq/" . $irq . "/smp_affinity";
	if (open(FILE, "< $fname")) {
		my $smpmap = readline(FILE);
		close(FILE);
		my $smplist = get_smp_list($smpmap, $irq);
		print "get_smp_affinity $fname smplist:$smplist\n" if $debug > 1;
		return $smplist;
	}

	# smp_affinity not present
	return "    -";
}

# XXX: not used
# Get number of interrupts per irq/cpu
sub get_num_ints
{
	my $irq = shift;
	my $cpu = shift;
	if ($ints_read == 0) {
		# read only once
		my $fname = "$toporoot/proc/interrupts";
		open(FILE, "< $fname") || die("can't open proc file: $fname");
		@ints = readline(FILE);
		close(FILE);
		$ints_read = 1;
	}

	foreach my $line (@ints) {
		if ($line =~ /\s+(\d+):/ && ($1 == $irq)) {
			$_ = $line;
			my @clist = split;
			return $clist[$cpu + 1];
		}
	}
	return 0;
}

sub get_int_counts
{
	if (!$have_irq_ints) {
		my $fname = "$toporoot/proc/interrupts";
		open(FILE, "< $fname") || die("can't open proc file: $fname");
		@irq_ints = readline(FILE);
		close(FILE);
		$have_irq_ints = 1;
	}
}

sub sum_int_counts
{
	my $irq = shift;
	my $irq_entry = shift;

	print "==== sum_int_counts\n" if $debug > 2;
	get_int_counts();

	$irq_entry =~ s/  */ /g;

	if ($irq_entry eq "") {
		my $idx = $irq . ": ";
		print "idx: $idx\n" if $debug > 1;
		foreach my $irqx (@irq_ints) {
			if ($irqx =~ /\s+(\d+):/) {
				if ($1 == $irq) {
					$irq_entry = $irqx;
					$irq_entry =~ s/  */ /g;
					$irq_entry =~ s/^ *//g;
					$irq_entry =~ s/ *$//g;
					$irq_entry =~ s/\n//g;
					my @entry = split(/ /, $irq_entry);
					$irq_devices[$irq] = pop @entry;
					last;
				}
			}
		}
	}
	print "sum: $irq_entry\n" if $debug > 2;

	my @counts = split(/ /, $irq_entry);
	shift @counts;
	shift @counts;
	$irq_counts[$irq] = 0;
	foreach my $cnt (@counts) {
		if ($cnt =~ /(\d+)/) {
			$irq_counts[$irq] += $cnt;
		}
	}
}

sub get_irq_ints
{
	my $device = shift;
	my @irqs = ();

	get_int_counts();

	foreach my $irq_entry (@irq_ints) {
		if ($irq_entry =~ /(\d+):.*($device\S+)/) {
			my $irq = $1;
			my $dev = $2;
			push(@irqs, $irq);
			$irq_devices[$irq] = $dev;
			chop $irq_devices[$irq];
			sum_int_counts($irq, $irq_entry) if $mode_irq_counts;
		}
	}
	return @irqs;
}

sub get_irqs
{
	my $devname = shift;
	my $dname = get_sysfs_dir($devname);
	opendir(DIR, "$dname") || die("can't open sys device directory: $dname");

	# if network device, there are many IRQ's
	my $netdev = $dname . "/net/";
	print "netdev $netdev\n" if $debug > 1;
	if (opendir(NDIR, "$netdev")) {
		# device is a network device
		my @devs = grep(!/^\./, readdir(NDIR));
		closedir(NDIR);
		foreach my $eth (@devs) {
			if ($eth =~ /(eth\d+)/) {
				print "eth $eth\n" if $debug > 1;
				return get_irq_ints($1);
			}
		}
	# ethX device not found?
	}

	# get IRQ #
	my $irq = read_file($dname . "/irq");
	my @irqs = ();
	push(@irqs, $irq);

	my $msi_irqs_dir = $dname . "/msi_irqs";
	print "msi_irqs_dir $msi_irqs_dir\n" if $debug > 1;
	if (opendir(my $dh, $msi_irqs_dir)) {
		my @msi_irqs = grep(!/^\./, readdir($dh));
		print "msi_irqs @msi_irqs\n" if $debug > 1;
		closedir($dh);
		shift @irqs if $irqs[0] eq $msi_irqs[0] and not $arg_affinity;
		push (@irqs, @msi_irqs);
	}

	sum_int_counts($irq, "") if $mode_irq_counts;
	print "get_irqs @irqs\n" if $debug > 1;
	return @irqs;
}

# reduce irq list to display ranges
# (Works with any sorted list of numbers)
sub condense_list
{
	my @irqs = @_;
	my $irqline = "";

	if (@irqs) {
		my $irq;
		my $lirq = -2;
		my $in_range = 0;
		my $lastirq = @irqs - 1;

		foreach my $nirq (@irqs) {
			$irq = $nirq;
			print "condense_list irq:$irq lirq:$lirq in_range:$in_range irqline:$irqline\n" if $debug > 2;
			if (($lirq + 1) == $irq) {
				$lirq = $irq;
				if (!$in_range) {
					$irqline .= "-";
					$in_range = 1;
				}
				next;
			}
			$irqline .= $lirq if $in_range;
			$irqline .= "," if $lirq >= 0;
			$lirq = $irq;
			if (length($irqline)) {
				$irqline .= $lirq;
			} else {
				$irqline = sprintf "%4d", $lirq;
			}
			$in_range = 0;
		}
		$irqline .= $irq if $in_range or $irq != $lirq;
	} else {
		$irqline = "-";
	}
	print "condense_list irqline:$irqline\n" if $debug > 1;
	return $irqline;
}

sub lookup_node_by_device
{
	my ($device) = @_;
	my $i;

	for ($i = 0; $i <= $#all_devices; $i++ ) {
		if ($device == $all_devices[$i]) {
			return $all_nodes[$i];
		}
	}
	printf("device %x not found in device/node array; aborting\n", $device);
	exit(1);
}

# read a file into $contents
sub get_contents {
	my ($FILEname) = @_;
	my ($contents);
	if (! defined open (CONFILE, $FILEname)) {
		$contents = "";
		return;
	}
	read CONFILE, $contents, -s $FILEname;
	close (CONFILE);
	chomp $contents;
	return $contents;
}

sub cache_pci_info
{
	my ($lspci_file) =@_;
	my $path=`which lspci 2>/dev/null`;
	chomp($path);
	print("Caching `lspci -m` at $lspci_file\n") if ($debug);
	if (! -x "$path") {
		printf("Unable to generate pci info: ".getpwuid($<)." cannot execute lspci\n".
		       "Run topology as root or choose lscpi file with --lspci=<file>\n");
		exit 1;
	}
	if (system("lspci -m 2>/dev/null 1>$lspci_file") ne 0) {
		printf("Unable to generate pci info: failed to write lspci output to $lspci_file\n");
		exit 1;
	}
}

# Cache nodes info into a text file
sub cache_nodes_info
{
	my $dir = $nodes_file;

	$dir =~ s/(..*)\/.*$/$1/;
	system("mkdir -p $dir");
	if (-e $sys_bus_nodepath) {
		system("ls $sys_bus_nodepath > $nodes_file");
	} elsif (-e $sys_dev_nodepath) {
		system("ls $sys_dev_nodepath > $nodes_file");
	} else {
		# we can only assume 1 node
		system("echo node0 > $nodes_file");
	}
}

# Cache cpu coreid and physical id
sub cache_cpu_ids
{
	my ($dir, @items, $cpu, $file1, $file2, $cid, $physid);

	$dir = $cpu_ids_file;
	$dir =~ s/(..*)\/.*$/$1/;
	system("mkdir -p $dir");
	open(FILE, "> $cpu_ids_file") || die("can't open $cpu_ids_file");

	# get the list of cpus
	$dir = $cpu_ids_base;
	$dir =~ s/\/cpuN.*//;
	if ((opendir DIR, $dir) == 0) {
		printf ("Error opening directory %s: %s\n", $dir, $!);
		return;
	}
	@items = readdir DIR;
	closedir DIR;
	for(@items) {
		# don't look in directories . or ..
		if ($_ =~ /cpu(\d{1,4})$/ ) {
			$cpu = $1;
			$dir = $cpu_ids_base;
			$dir =~ s/N/$cpu/ ;
			$file1 = "$dir/core_id";
			$cid = get_contents($file1);
			$file2 = "$dir/physical_package_id";
			$physid = get_contents($file2);
			printf(FILE "%d %d %d\n", $cpu, $cid, $physid);
		}
	}
	close (FILE);
}

# walk the files under arg[0]
# receives an absolute path directory name
sub walk_dir_for_device_nodes {
	my $dirfull = @_[0]; # directory name (relative to server's root)
	my ($filefull, $fileshort);

	if ((opendir DIR, $dirfull) == 0) {
		printf ("Error opening directory %s: %s\n", $dirfull, $!);
		return;
	}

	# get all the items in this directory
	my @items = readdir DIR;
	closedir DIR;
	my @dirs = ();

	for(@items) {
		# don't look in directories . or ..
		if ($_ eq "." || $_ eq "..") {
			next;
		}
		my $filefull = "$dirfull/$_";
		my $nodeline;
		my $node;
		my $minus;
		my $device_string;
		my $device;
		if (-f $filefull) { # plain file
			if ($_ eq "numa_node") {
				$numa_nodes_found++;
				open(NODEFILE, "< $filefull") || die("can't read $filefull");
				my @ndata = readline(NODEFILE);
				close(NODEFILE);
				foreach $nodeline (@ndata) {
					if ($nodeline =~ /(\-*)(\d{1,4})$/ ) {
						$minus = $1;
						$node = $2;
						if ($minus ne "-") {
							$device_string = $dirfull;
							# use the last component e.g. 0000:85:00.0
							$device_string =~ s/..*\/(.*)$/$1/;
							if ($device_string =~
							    /^(\S\S\S\S):(\S\S):(\S\S)\.(\S)$/ ) {
								my $seg = hex($1);
								my $bus = hex($2);
								my $dev = hex($3);
								my $func = hex($4);
								$device = $func + ($dev << 8) +
									($bus << 16) + ($seg << 24);
							} else {
								printf(
							    "unknown device in %s: %s;\n",
									$dirfull, $device_string);
							}
							printf(FILE "%x %d\n", $device, $node);
						}
					}
				}
			}
		} elsif (-l $filefull) { # symbolic link
			next;
		} elsif (-d $filefull) { # directory
			push @dirs, $filefull; # add to right side of array
		}
	}
	for(@dirs) {
		&walk_dir_for_device_nodes($_);
	}
}

# Cache /sys info on devices and nodes
# return 0 cache is made; 1 for not made (including no entries)
sub cache_device_nodes
{
	my $dir;

	$dir = $device_nodes_file;
	$dir =~ s/(..*)\/.*$/$1/; #greedy:finds longest string ending w/ /
	system("mkdir -p $dir");
	open(FILE, "> $device_nodes_file") || die("can't open $device_nodes_file");
	walk_dir_for_device_nodes($sys_devices);
	close FILE;

	if ($numa_nodes_found) {
		return 0;
	} else {
		return 1;
	}
}

# Cache a node's cpus into a text file
sub cache_node_cpus
{
	my ($nid) = @_;
	my ($dir, $cpudir, @items);

	$dir = $nodes_cpus_file;
	$dir =~ s/(..*)\/.*$/$1/;
	system("mkdir -p $dir");

	if (-e $sys_bus_nodepath) {
		system("echo node$nid >> $nodes_cpus_file");
		$cpudir = "$sys_bus_nodepath" . "/" . "node$nid";
		system("ls $cpudir | grep ^cpu >> $nodes_cpus_file");
	} elsif (-e $sys_dev_nodepath) {
		system("echo node$nid >> $nodes_cpus_file");
		$cpudir = "$sys_dev_nodepath" . "/" . "node$nid";
		system("ls $cpudir | grep ^cpu >> $nodes_cpus_file");
	} else {
		if ($nid != 0) {
			printf("%s and %s do not exist; aborting\n",
				$sys_bus_nodepath, $sys_dev_nodepath);
			exit(1);
		}
		$dir = $sys_dev_cpupath;
		if ((opendir DIR, $dir) == 0) {
			printf ("Error opening directory %s: %s\n", $dir, $!);
			exit(1);
		}
		@items = readdir DIR;
		closedir DIR;
		open(FILE, "> $nodes_cpus_file") || die("can't open $nodes_cpus_file");
		printf(FILE "node0\n");
		for(@items) {
			if ($_ =~ /^cpu\d{1,4}/ ) {
				printf(FILE "%s\n", $_);
			}
		}
		close FILE;
	}
}

# Cache /sys pci info where all devices are on node 0
sub
cache_pci_node0
{
	my $dir;
	my @items;

	$dir = $device_nodes_file;
	$dir =~ s/(..*)\/.*$/$1/; #greedy:finds longest string ending w/ /
	system("mkdir -p $dir");
	open(FILE, "> $device_nodes_file") || die("can't open $device_nodes_file");

	$dir = $pci_devices;
	if ((opendir DIR, $dir) == 0) {
		printf ("Error opening directory %s: %s\n", $dir, $!);
			return;
	}
	@items = readdir DIR;
	closedir DIR;
	for(@items) {
		if ($_ =~ /^(\S\S\S\S):(\S\S):(\S\S)\.(\S)$/ ) {
			my $seg = hex($1);
			my $bus = hex($2);
			my $dev = hex($3);
			my $func = hex($4);
			my $device = $func + ($dev << 8) + ($bus << 16) + ($seg << 24);
			printf(FILE "%x 0 0000:00\n", $device);
		}
	}
	close FILE;
}

# parse the file of cpu core and physical ids
#$cpus{$cpunum} = {
# physid
# coreid
# };
sub parse_cpu_ids
{
	my ($cpuid_entry, $cpu, $cid, $physid, $cnt);

	if (-e $cpu_ids_file) {
		open(FILE, "< $cpu_ids_file") || die("can't get cpu id input");
	} else {
		printf("%s does not exist; aborting\n", $cpu_ids_file);
		exit(1);
	}
	@cpuidsdata = readline(FILE);
	close(FILE);
	foreach $cpuid_entry (@cpuidsdata) {
		if ($cpuid_entry =~ /^(\d{1,4}) (\d{1,4}) (\d{1,4})/ ) {
			$cpu = $1;
			$cid = $2;
			$physid = $3;
			$cnt++;
			$cpus{$cpu}->{"coreid"} = $cid;
			# $cpus{$cpu}->{"physid"} = $physid; is same as node
		} else {
			printf("invalid line in %s; aborting\n", $cpu_ids_file);
	exit(1);
		}
	}
	return $cnt;
}

sub parse_device_nodes
{
	my $devnode_entry;
	my $nid;
	my $cnt;
	my $device;

	if (-e $device_nodes_file) {
		open(FILE, "< $device_nodes_file") || die("can't get device/nodes input");
	} else {
		printf("%s does not exist; aborting\n", $device_nodes_file);
		exit(1);
	}
	@devicenodesdata = readline(FILE);
	close(FILE);
	foreach $devnode_entry (@devicenodesdata) {
		if ($devnode_entry =~ /^(\S+) (\d{1,4})/ ) {
			$device = hex($1);
			$nid = $2;
			push @all_devices, $device;
			push @all_nodes, $nid;
			$cnt++;
		}
	}
	if ($cnt) {
		return 0;
	} else {
		return 1;
	}
}

# parse the file of nodeN followed by all the cpuNN's in that node
# collect this kind of cpu information, primarily number and node
#$cpus{$cpunum} = {
# blade
# node
sub parse_node_cpus
{
	my $nodecpu_entry;
	my $cur_nid;
	my $cpunum;
	my $others;

	if (-e $nodes_cpus_file) {
		open(FILE, "< $nodes_cpus_file") || die("can't get node/cpus input");
	} else {
		printf("%s does not exist; aborting\n", $nodes_cpus_file);
		exit(1);
	}
	@nodescpusdata = readline(FILE);
	close(FILE);
	foreach $nodecpu_entry (@nodescpusdata) {
		if ($nodecpu_entry =~ /^node(\d{1,4})/ ) {
			$cur_nid = $1
		} elsif ($nodecpu_entry =~ /^cpu(\d{1,4})/ ) {
			$cpunum = $1;
			$cpus{$cpunum}->{"blade"} = $cur_nid;
		} elsif ($nodecpu_entry =~ /^cpu/ ) {
			$others++;
		} else {
			printf("invalid line in %s; aborting\n", $nodes_cpus_file);
			exit(1);
		}
	}
}

# save this kind of node information:
# $nodecount (our return value)
# $node_id[$1] = $2;
sub parse_nodes_info
{
	my $nodes_entry;
	my $nid;
	my $cnt;

	if (-e $nodes_file) {
		open(FILE, "< $nodes_file") || die("can't get nodes input");
	} else {
		printf("%s does not exist; aborting\n", $nodes_file);
		exit(1);
	}
	@nodesdata = readline(FILE);
	close(FILE);

	foreach $nodes_entry (@nodesdata) {
		if ($nodes_entry =~ /^node(\d{1,2})/ ) {
			$nid = $1;
			push @node_id, $nid;
			cache_node_cpus($nid);
			$cnt++;
			$node_class[$nid] = "node";
		}
	}
	parse_node_cpus();
	return $cnt;
}

sub nilink_reroute_event
{
# possibilities for nilink_rerouting file:
#   hasn't been looked at yet, contains something - copy file to /var/run/sgi_uv
#   has been looked at, but differs from before - copy file to /var/run/sgi_uv
#   contains nothing - do nothing  my $nirr_proc_file = "/proc/sgi_uv/nilink_rerouting";

	if ((-e $nirr_proc_file)) {
		my $data_in_proc_file = 0;

		open(FILE, "< $nirr_proc_file") || die("can't open nilink_rerouting file: $nirr_proc_file");
		my @nirr_data = readline(FILE);
		close(FILE);

		if (@nirr_data == 0) {
			print "$nirr_proc_file is empty\n" if $debug;
			return;
		} else {
			my $nirr_tmp_file = "/tmp/$$" . int(rand(1000000)) . ".tmp";

			copy($nirr_proc_file, $nirr_tmp_file) ||
			     die("unable to copy $nirr_proc_file to $nirr_var_file");
			chmod 0600, $nirr_tmp_file;

			if (compare($nirr_tmp_file, $nirr_var_file) || !(-e $nirr_var_file)) {
				print "copying $nirr_tmp_file to $nirr_var_file\n" if $debug;
				copy($nirr_tmp_file, $nirr_var_file) ||
				    die("unable to copy $nirr_proc_file to $nirr_var_file");
				chmod 0600, $nirr_var_file;

				#TODO: fix for strict
				#openlog($0, "", LOG_WARNING);
				#syslog(LOG_INFO, "NI links have been reconfigured or have reached CRC threshold.\n");
				#closelog();

				if (!$arg_hdrs) {
					print "NI Link Re-routes:\n";
				}

				if (!$verbose) {
					print "  NI links have been reconfigured or have reached CRC threshold.\n"
				}
			}

			unlink $nirr_tmp_file;

			if ($verbose) {
				my $nirr_entry;

				if (!$arg_hdrs) {
					print "  Node              Reroutes?         Threshold Hit?\n";
					print "  --------------------------------------------------\n";
				}

				foreach $nirr_entry (@nirr_data) {
					if ($arg_hdrs) {
						print $nirr_entry;
					} else {
						my ($node, $rr, $prr, $crc) = ($nirr_entry =~ /(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/);
						my $reroutes = "no";
						my $crc_errors = "no";

						if (hex($rr) || hex($prr)) {
							$reroutes = "yes";
						}

						if (hex($crc)) {
							$crc_errors = "yes";
						}

						printf "  %12s         %3s               %3s\n", $node, $reroutes, $crc_errors;
					}
				}
			}
		}
	} elsif ($hub_type == UV1) {
		return; #NI Link Re-routes no supported on UV1
	} else {
		print "No NI Link Re-route information found.  Is the hwperf module installed?\n";
		exit 2;
	}
}

sub init_assigned
{
	# fill in assigned display table
	if (!$arg_nox) {
		foreach my $disp (keys (%displays)) {
			my $devid = $devids{ $displays{ $disp } };
			my $dev = $devices{ $devid };
			my $screen = $disp;
			my $screen_number = $screen_numbers{ $screen };
			$assigned{$screen_number} = $disp;
			print "ASSIGN $screen_number $disp\n" if $debug;
		}
	}
}

sub print_unassigned
{
	# print table of Devices assigned in xorg.conf that do not exist.
	if ($headers && !$arg_nox) {
		my $disp;
		my $hdr = 0;
		foreach my $disp (keys (%displays)) {
			my $sn = $screen_numbers{ $disp };
			if ($assigned{ $sn } ne "") {
				my $devid = $devids{ $displays{ $disp } };
				my $dev = $devices{ $devid };
				my $x = ($dev >> 24) & 255;
				my $y = ($dev >> 16) & 255;
				my $z = ($dev >>  8) & 255;
				if (!$hdr++) {
					print "\n";
				}
				printf STDERR
				    "WARNING: %s at %04x:%02x:%02x.0 is X Display %s in xorg.conf but does not exist!\n",
				    $devid, $x, $y, $z, $assigned{ $sn };
			}
		}
		if ($hdr) {
			print "\n";
		}
	}
}

sub get_device_type
{
	my ($class, $vendor) = @_;
	my $devtype = "";

	if ($class =~ /VGA|3D|Multimedia/ || $vendor =~ /Teradici/) {
		$devtype = "GPU";
	} elsif ($class =~ /SCSI|SATA|Fibre|RAID|Serial/) {
		$devtype = "DSK";
	} elsif ($class =~ /Ethernet|Infiniband|Network/) {
		$devtype = "NET";
	} elsif ($class =~ /Co-processor/) {
		$devtype = "COP";
	} elsif ($class =~ /Non-Volatile/) {
		$devtype = "NVMC";
	} elsif ($class =~ /USB/) {
		$devtype = "USB";
	} elsif ($class =~ /Fabric/) {
		$devtype = "NET";
	} elsif ($class =~ /Input/) {
		$devtype = "INPUT";
	} elsif ($class =~ /PCI bridge/ && !($vendor =~ /Intel/)) {
		# Most/all Intel cards of this class are noise in this context
		$devtype = "BRIDGE";
	}

	return $devtype;
}

sub get_device_id
{
	my $slot = "@_";
	my $devid = 0;
	my ($d, $b, $s, $f);
	#domain:bus:socket.function
	if ($slot =~ /([[:xdigit:]]+):([[:xdigit:]]+):([[:xdigit:]]+)\.([[:xdigit:]]+)/) {
		$d = hex("$1");
		$b = hex("$2");
		$s = hex("$3");
		$f = hex("$4");
		$devid = ((((($d << 8) | $b) << 8) | $s) << 8) | $f;
	#bus:socket.function
	} elsif ($slot =~ /([[:xdigit:]]+):([[:xdigit:]]+)\.([[:xdigit:]]+)/) {
		$d = 0;
		$b = hex("$1");
		$s = hex("$2");
		$f = hex("$3");
		$devid = ((((($d << 8) | $b) << 8) | $s) << 8) | $f;
	} else {
		print "ERR: ould not determine device ID number\n" if ($debug);
	}

	return $devid;
}

sub get_custom_device_desc
{
	my ($class, $vendor, $lspci_desc) = @_;
	my ($devdesc, $desc_str);
	my @args;

	# load custom defintions if they haven't been loaded already
	if (!@custom_pci_defs) {
		if (!open(FILE, "<", $pci_defs_file)) {
			print "ERROR: Cannot open $pci_defs_file\n";
			return "";
		}
		@custom_pci_defs = readline(FILE);
		close(FILE);
	}

	# look for a match on vendor, class, and description
	my $match_found = 0;
	foreach (@custom_pci_defs) {
		next if ($_ =~ /^#.*/); # skip comments
		my ($v, $c, $regexp);
		chomp($_);

		($v, $c, $regexp, $desc_str) = quotewords(' ', 0, $_);
		print "entry: $v | $c | $regexp | $desc_str" if ($debug gt 2);
		if (($vendor =~ /$v/) && ($class =~ /$c/) &&
		    (@args = $lspci_desc =~ /$regexp/)) {
			# got a match, exit
			$match_found = 1;
			last;
		}
	}

	if ($match_found) {
		print "args: @args\n" if ($debug gt 2);
		print "Using custom PCI device description\n" if ($debug gt 1);

		# parse descriptor string
		my @fields = split(/ /, $desc_str, -1);
		$devdesc = "@fields[0]"; shift @fields;
		foreach (@fields) {
			# process $x as if we called it directly
			if ($_ =~ /\$([0-9]+)/) {
				$devdesc = "$devdesc $args[$1-1]";
			} else {
				$devdesc = "$devdesc $_";
			}
		}
	}

	return $devdesc;
}

sub get_device_desc
{
	my ($id, $class, $vendor, $lspci_desc) = @_;
	my ($vendor_short) = $vendor =~ /(\S+)\s.*/;
	my ($class_short) = $class =~ /(\S+)\s.*/;
	my $devdesc;
	my $tw = 50; # target device name width
	my $rm = "( chipset| card| series| mode)";

	# Handle devices with no name in the pci id database
	if ($lspci_desc =~ /^Device (\S+)/) {
		$devdesc = get_custom_device_desc($class, $vendor, $lspci_desc);
		if ($devdesc eq "") {
			$devdesc = "$vendor_short $class device $1";
		}
		$footnotes[F_DEV_DESC_MISSING]{$id} = 1;
		return $devdesc;
	}

	# Modify lspci device description for brevity and clarity
	$devdesc = $lspci_desc;
	$devdesc =~ s/$rm//gi;
	$devdesc =~ s/$vendor//gi;
	if (!($devdesc =~ /$vendor_short/)) {
		$devdesc = "$vendor_short $devdesc";
	}
	if (length $devdesc gt $tw) { $devdesc =~ s/$class/$class_short/gi; }
	if (length $devdesc gt $tw) { $devdesc =~ s/\(.*\)//gi; }
	if (length $devdesc gt $tw) { $devdesc =~ s/\[.*\]//gi; }
	$devdesc =~ s/\s+/ /g; #remove extra whitespace

	return $devdesc;
}

sub process_lspci_entry
{
	my ($lspci_entry) = @_;
	my ($slot, $vendor, $class, $desc);
	print "\n$lspci_entry" if ($debug > 1);

	# parse information from `lspci -m` entry
	my @fields = quotewords(' ', 0, $lspci_entry);
	($slot, $class, $vendor, $desc) = grep { !/^-\S+$/ } @fields;

	# get statistics on devices of each class
	if ($class =~ /3D/)                     { $gpgpucount++; }
	if ($class =~ /Co-processor/)           { $copcount++; }
	elsif ($class =~ /Ethernet/)            { $netcount++; }
	elsif ($class =~ /Fibre/)               { $fibcount++; }
	elsif ($class =~ /Infiniband/)          { $ibcount++; }
	elsif ($class =~ /Multimedia/)          { $vancount++; }
	elsif ($class =~ /Network/)             { $netcount++; }
	elsif ($class =~ /SCSI/)                { $scsicount++; }
	elsif ($class =~ /SATA/)                { $satacount++; }
	elsif ($class =~ /USB/)                 { $usbcount++; }
	elsif ($class =~ /VGA/)                 { $vgacount++; }
	elsif ($class =~ /RAID/)                { $raidcount++; }
	elsif ($class =~ /Non-Volatile/)        { $nvmccount++; }
	return if ($mode_summ && !($mode_cop || $mode_dsk || $mode_gfx ||
	           $mode_net || $mode_nvmc));

	# process pci device information
	my $devtype = get_device_type($class, $vendor);
	if ($devtype eq "") {
		print "WARN: No type found for class: $class\n" if ($debug gt 1);
		return;
	}
	my $devid = get_device_id("$slot");
	my $devdesc = get_device_desc($devid, $class, $vendor, $desc);
	$devtypes{"$devid"} = $devtype;
	$pcidevs{"$devid"} = $devdesc;

	if ($debug gt 1) {
		printf("%10s %s\n", "slot", $slot);
		printf("%10s %s\n", "class", $class);
		printf("%10s %s\n", "vendor", $vendor);
		printf("%10s %s\n", "devtype", $devtype);
		printf("%10s 0x%010x\n", "devid", $devid);
	}
	print "$desc -> $devdesc\n" if ($debug);
}

# Check that the lspci entry is in machine readable format, i.e. made up of
# the pci slot, five quote-surrounded fields, and optional arguments. Example:
# 00:00.0 "Host bridge" "Intel Corporation" "Xeon E7 v3/Xeon E5 v3/Core i7 DMI2" \
# -r02 "Silicon Graphics Intl. Corp." "Device 2f00"
sub machine_readable_lspci_fmt
{
	my ($lspci_entry) = @_;
	my $pci_slot = '[0-9a-fA-F\.\:]+';
	my $opt_arg = '\-[^"]+';
	my $field = '\"[^"]*\"';

	if ($lspci_entry =~ /$pci_slot((\s|\s$opt_arg\s)+$field){5}/) {
		return 1;
	} else {
		return 0;
	}

}

sub parse_lspci_devices
{
	open(FILE, $lspci_file) || die("ERR: cannot open $lspci_file");
	my @pcidata = readline(FILE);
	close(FILE);

	if (!@pcidata) { return 1; }

	if (!machine_readable_lspci_fmt($pcidata[0])) {
		print("ERROR: wrong lspci output format in file $lspci_file, ");
		if ($lspci_file eq $lspci_var_file) {
			print("restart sgi_configuration service or ");
		}
		print("run `lspci -m > $lspci_file` to refresh.\n");
		exit(1);
	}

	my $pci_entry;
	foreach $pci_entry (@pcidata) {
		process_lspci_entry($pci_entry);
	}
}

# print out misc. I/O devices  --io --cops --disks --gfx --networks --nvmc
sub print_io
{
	if ($debug > 1) {
		my $str = "print_io: ";
		$str .= "cop " if $mode_cop;
		$str .= "dsk " if $mode_dsk;
		$str .= "gfx " if $mode_gfx;
		$str .= "gfx_only " if $mode_gfx_only;
		$str .= "net " if $mode_net;
		$str .= "nvmc " if $mode_nvmc;
		print "$str\n";
	}

	# fill in assigned table to discover which devices are not assigned
	init_assigned();

	if ($headers) {
		my $h0 = ""; my $d0 = "";
		if ($hub_type == UV2) {
			$h0 = "  ";
			$d0 = "--";
		}
		my $h1 = ""; my $d1 = "";
		if($arg_affinity) {
			$h1 = sprintf " IRQ %*s", $cpuwidth, "CPUS";
			$d1 = "------------";
			$d1 .= substr($dashes, 0, $half_cpuwidth);
		} elsif ($arg_irqs) {
			$h1 = "        IRQ(s)";
			$d1 = "--------------";
		} elsif ($verbose) {
			if ($hub_type == UV1) {
				$h1 = " Nodes";
				$d1 = "------";
			} elsif ($hub_type >= UV2) {
				$h1 = "Node";
				$d1 = "----";
			}
			my $cpuw = $cpuwidth;
			$cpuw -= 2 if $hub_type >= UV3;
			$h1 .= sprintf "%*s", $cpuw, "    Local CPUS ";
			$d1 .= substr($dashes, 0, $cpuw);
		}
		if ($mode_irq_counts) {
			$h1 .= "     INTCNT ";
			$d1 .= "------------";
		}

		my $h2 = "";
		my $d2 = "";
		if (!$arg_nox) {
			$h2 = sprintf "%${screen_width}s", " X Display   ";
			$d2 = sprintf "%${screen_width}s", "-------------";
		}
		if (!$has_topology) {
		    printf "\n Node   PCI Address   %s%s    Device\n", $h1, $h2;
		    printf " %s---------------------------------%s%s--------------\n",
			       $d0, $d1, $d2;
		} else {
		    printf "\nIndex %sLocation    NASID  PCI Address   %s%s    Device\n",
			       $h0, $h1, $h2;
		    printf "------%s----------------------------------%s%s--------------\n",
			       $d0, $d1, $d2;
		}
	}

	my $last_slotid = "";

	for (my $i = 0; $i < $nodecount; $i++) {
		my $nid = $node_id[$i];
		my $nasid = $node_nasid[$i];
## print "\t--- pci pass $i/$nodecount nid $nid nasid $nasid\n" if $debug > 2;
		if ($i == 0 || exists $risers{$nid}) {
			my $pcibus;
			my $nextpcibus;

			if ($i == 0) {
				$pcibus = 0;
			} else {
				$pcibus = $risers{$nid} + 0;
			}

			if ($risercount > 1 and defined $pcibusincrs{$pcibus}) {
				my $pcibi = $pcibusincrs{$pcibus};
				$nextpcibus = $pcibus + $pcibi;
				print "\t--- pcibus $pcibus pcibi $pcibi nextpcibus $nextpcibus\n" if $debug > 1;
			} else {
				$nextpcibus = $pcibus + 0x100;
				print "\t--- pcibus $pcibus AUTOINCR 0x100 nextpcibus $nextpcibus\n" if $debug > 1;
			}

			printf("--- nid %s nasid %04x pcibus %x next %x\n",
			       $nid, $nasid, $pcibus, $nextpcibus) if $debug > 1;

			foreach my $device (sort bynumber keys (%pcidevs)) {
				my $disp;
				my $input;
				my $extras = "";
				my $devname;
				my $pciaddr;
				my $dodisplay = ($get_node eq "") && ($get_cpus eq "");
				my $x = $device >> 16;
				my $devtype = $devtypes{$device};
				my $nextline = 0;

				printf("%s  %06x %06x %06x %x\n",
				       $devtype, $x, $pcibus, $nextpcibus, $device) if $debug > 1;

				next if (!$arg_io && $devtype eq "INPUT");
				next if (!$arg_io && $devtype eq "BRIDGE");
				next if (!$mode_cop && $devtype eq "COP");
				next if (!$mode_dsk && $devtype eq "DSK");
				next if (!$mode_gfx && $devtype eq "GPU");
				next if (!$mode_net && $devtype eq "NET");
				next if (!$mode_nvmc && $devtype eq "NVMC");
				next if ($arg_nomga && $device eq $mgadevid);

				if ($x >= $pcibus && $x < $nextpcibus) {
					my ($d, $b, $s, $f) = get_pciid($device);

					$devname = $pcidevs{$device};
					$pciaddr = sprintf "%04x:%02x:%02x.%x", $d, $b, $s, $f;

					printf("\nDEV ====== %s: %x %s %s\n",
						$devname, $device, $devtype, $pciaddr) if $debug; # > 1;
					if ($get_pciids) {
						print "$pciaddr\n";
					next;
					}

					if ($footnotes[F_DEV_DESC_MISSING]{$device}) {
						$devname = append_footnote_key(F_DEV_DESC_MISSING, $devname);
					}

					my $numdevs = $subdevices{$device} + 0;
					my $subdev = 0;
					printf("subdevices{%x} = %s\n", $device, $numdevs) if $debug > 2;

					do {
						my $blade;
						my $id = $i;
						my $slot_id;
						if ($has_topology) {
						    $slot_id = get_slot_id($nid, $d, $b);
						} else {
						    # do . . . continuation lines based on device, not UV blade slot
						    $slot_id = $device;
						}

						if ($hub_type >= UV3) {
							my $dname = get_sysfs_dir($pciaddr);
							$id = read_file($dname . "/numa_node");
						}

						if ($debug > 1) {
							print
							  "slot_id:$slot_id last_slotid:$last_slotid hub:$hub_name\n"
						}
						if ($headers and $slot_id eq $last_slotid) {
							$nextline = 1;
						}
						if (!$has_topology) {
							# without topology we don't know slot
							$nextline = 0;
						}

						if ($nextline) {
							if (!$has_topology) {
								my $node;
								$node = lookup_node_by_device($device);
								$blade = sprintf " %4d ", $node;
							} elsif ($hub_type == UV1) {
								$blade = sprintf " %4s %10s %6s", ".", ".", "."
							} elsif ($hub_type == UV2) {
								$blade = sprintf " %4s %12s %6s", ".", ".", "."
							} elsif ($hub_type >= UV3) {
								$blade = sprintf " %4s %10s %6s", ".", ".", ".";
							}
						} else {
							if (!$has_topology) {
								my $node;
								$node = lookup_node_by_device($device);
								$blade = sprintf " %4d ", $node;
							} elsif ($hub_type == UV1) {
								$blade = sprintf " %4d %10s   %04x", $i, $nid, $nasid
							} elsif ($hub_type == UV2) {
								$blade = sprintf " %4d %12s   %04x", $i, $nid, $nasid
							} elsif ($hub_type >= UV3) {
								$blade = sprintf " %4d %10s   %04x", $i, $slot_id, $nasid;
							}
						}
						if ($debug > 1) {
							print "slot_id:$slot_id last_slotid:$last_slotid blade:$blade\n"
						}
						$last_slotid = $slot_id;

						if ($dodisplay) {
							if ($arg_irqs) {
								my @irqs = get_irqs($pciaddr);
								my $irqcnt = 0;
								my $numirqs = @irqs;
								print ("pciaddr:$pciaddr irqs:@irqs ($numirqs)\n") if $debug > 1;
								my $opciaddr = $pciaddr;
								if ($mode_irq_counts) {
									foreach my $irq (@irqs) {
										$irqcnt += $irq_counts[$irq]
									}
								}
								if (!$arg_affinity) {
									my $irqline = condense_list(@irqs);
									$extras = sprintf "  %14s", $irqline;
									$extras .= sprintf "%11d ", $irqcnt if $mode_irq_counts;
								} else {
									if (@irqs) {
										my $zap = 0;
										my @null_irqs = ();
										my $lirq = -1;

										get_online_cpus();
										foreach my $irq (@irqs) {
											my $irql = "";
											my $smplist = get_smp_affinity($irq);
											my $netname = $devname;

											print "netname:$netname irq:$irq smplist:$smplist zap:$zap\n" if $debug > 1;
											if ($smplist eq $online_cpus and $zap) {
												push @null_irqs, $irq;
												next;
											}
											if ($zap) {
												if ($headers) {
													if ($hub_type == UV3) {
														$blade = sprintf " %10s %6s", ".", ".";
													} elsif ($hub_type == UV4) {
														$blade = sprintf " %8s %6s", ".", ".";
													} else {
														$blade = sprintf " %4s %12s %6s", ".", ".", ".";
													}
													if ($has_topology) {
														$opciaddr = sprintf "%12s", ".";
													}
												}
												$netname = "";
												$netname = "   " . $irq_devices[$irq] . "   " if length $irq_devices[$irq];
											}
											$irql = sprintf "%10d", $irq_counts[$irq] if $mode_irq_counts;
											my $lineout;
											if ($headers and $irq eq $lirq and $zap eq 1 and $numirqs eq 2) {
												print "zapping irq:$irq lirq:$lirq zap:$zap numirqs:$numirqs\n" if $debug > 1;
												$irql = sprintf "%10s", ".";
												$irq = ".";
												$smplist = ".";
											}
											if (! $has_topology) {
												$lineout = sprintf "%-4s  %s %5s:%*s %s   %s",
												                   $blade, $opciaddr, $irq,
												                   $cpuwidth, $smplist, $netname;
											} elsif ($hub_type >= UV3) {
												$lineout = sprintf "%-17s  %s %5s:%*s %s   %s",
												                   $blade, $opciaddr, $irq, $cpuwidth,
												                   $smplist, $irql, $netname;
											} else {
												$lineout = sprintf "%-23s  %s %5s:%*s %s   %s",
												                   $blade, $opciaddr, $irq, $cpuwidth,
												                   $smplist, $irql, $netname;
											}
											printf "smplist:%*s lineout:'%s'\n", $cpuwidth, $smplist, $lineout if $debug > 1;

											if ($zap == 1) {
												my $node = get_devnode($pciaddr);
												my $cpulist = get_cpulist($node);
												$lineout .= sprintf "   [local CPUs:%s]", $cpulist;
											}
											printf "%s\n", $lineout;
											$zap++;
											$lirq = $irq;
										} # foreach my $irq
										if (@null_irqs) {
											my $irqline = condense_list(@null_irqs);
											if (! $has_topology) {
												printf "%4s  %s %5s: %s\n",
												$blade, $opciaddr, $irqline, $online_cpus;
											} elsif ($hub_type >= UV3) {
												printf "%-17s  %s  %5s: %s\n",
												$blade, $opciaddr, $irqline, $online_cpus;
											} else {
												printf "%-23s  %s  %5s: %s\n",
												$blade, $opciaddr, $irqline, $online_cpus;
											}
										}
										next; # goto next device
									} # if ($arg_affinity)
									my $irql = " ";
									$irql = sprintf(" %10d", 0) if $mode_irq_counts;
									$extras = sprintf "%6s %7s%s", "-", "-", $irql;
								} # if ($arg_irqs)
							} elsif ($verbose) {
								my $node = get_devnode($pciaddr);
								my $cpulist = get_cpulist($node);

								if (!$has_topology) {
									$extras = sprintf " %*s", $cpuwidth, $cpulist;
								} else {
									my $nodelist = get_nodelist($node);
									my $nwid = 6; $nwid = 8 if $hub_type == UV1;
									$extras = sprintf "%*s %*s", $nwid, $nodelist, $cpuwidth, $cpulist;
								}
							}
						}

						my $xdisplay = "";
						if (!$arg_nox) {
							my $screen = "-";
							$screen = get_display($device, $subdev, $i) if ($devtype eq "GPU");
							$xdisplay = sprintf "%${screen_width}s  ", $screen;
							print "xdisplay '$xdisplay'\n" if $debug > 2;
						}

						if ($dodisplay) {
							if (!$has_topology) {
								printf "%4s  %s%s   %s     %s\n",
								    $blade, $pciaddr, $extras, $xdisplay, $devname;
							} elsif ($hub_type >= UV3) {
								printf "%-17s  %s%s   %s%s\n",
								    $blade, $pciaddr, $extras, $xdisplay, $devname;
							} else {
								printf "%-23s  %s%s   %s%s\n",
								    $blade, $pciaddr, $extras, $xdisplay, $devname;
							}
							if ($headers && ($hub_type <= UV3)) {
								$nextline = 1;
							}
						}

					# repeat line for each subdevice
					} until (++$subdev >= $numdevs);
				}
			} # for (my $i = 0; $i < $nodecount; $i++) {
		# ... other devices here ...
		}

#		(remove empty blades)
#		elsif ($headers) {
#			printf " %4d %10s %6d\n", $i, $nid, $node_nasid[$i];
#		}

	}

	print_unassigned();
}

sub get_monitors_from_log
{
	print "\n---\nGET MONITORS\n" if $debug > 1;
	my @mons = `grep NVIDIA $toporoot/var/log/Xorg.0.log`;

	foreach (@mons) {
		my $gpu;
		my $disp;
		print "LINE: " . $_ if $debug > 2;

		if ($connected) {
			if (/NVIDIA\((\d+)\):     (.*)$/) {
				$gpu = $1;
				$disp = $2;
			} else {
				$connected = 0;
				next;
			}
		} elsif (/Connected display device/) {
			$connected = 1;
			print ".................... connected\n" if $debug > 1;
			next;
		} elsif (/NVIDIA GLX Module\s+([\d+\.]+)/) {
			print ".................... version $1\n" if $debug > 1;
			next;
		} else {
			next;
		}

		if (defined($logdisplay{$gpu})) {
			$logdisplay{$gpu} .= ":".$disp;
		} else {
			$logdisplay{$gpu} = $disp;
		}
		print "logdisplay{$gpu} = $logdisplay{$gpu}\n" if $debug;
	}

	my $log = "$toporoot/var/log/Xorg.0.log";
	my $conf = "$xorgconf";
	system ("[ $conf -nt $log ] &&
	        echo -e \"\nWARNING: $conf has changed since $log created\" > /dev/stderr");
}

# print out Xorg.conf table   --xorg
sub print_x
{
	my $gpu = 0;
	my $last_devid;

	get_pci_nodes();
	get_monitors_from_log();

	my $nwid = 7;
	$nwid = 3 if $nodecount < 10;
	$nwid = 5 if $nodecount < 100;
	$nwid = 4 if $hub_type >= UV2;

	if ($headers) {
		my $h3 = "";
		my $d3 = "";
		if ($hub_type == UV1) {
			$h3 = "s";
			$d3 = "-";
		}
		my $h1 = sprintf "%${nwid}s%s", " Node", $h3;
		my $d1 = sprintf "%${nwid}s%s", "-----", $d3;
		my $h2 = sprintf "%${screen_width}s", " X Display  ";
		my $d2 = sprintf "%${screen_width}s", "------------";
		printf "\n%s   BusID %s         Device               Monitors\n", $h1, $h2;
		printf "%s---------%s-----------------------------------------\n", $d1, $d2;
	}

	foreach my $scrn (sort bynumber keys (%screens)) {
		printf("\n=== SCREEN %2d %s\n", $scrn, $screens{$scrn}) if $debug > 1;
		my $display = $screens{$scrn};
		my $screen = $displays{$display};
		my $device = $devids{$screen};
		my $devid = $devices{$device};
		my ($d, $b, $s, $f) = get_pciid($devid);
		my $busid = $b ."@". $d .":". $s .":". $f;

		## my $bid = $d * 256 + $b & ~($pcibusincr - 1);
		## (change not yet verified)
		my $pciid = ($d << 8) | $b;
		my $bid = $pciid & ~($pcibusincrs{$pciid});

		my $node = $pci_nodes{$bid};
		my $nodes = $node;
		$nodes = sprintf "%d,%d", $node, $node+1 if $hub_type == UV1;
		my $devname = $pcidevs{$devid};
		if ($debug > 1) {
			my $d = sprintf "devid %x bid %x", $devid, $bid;
			print "--- display $display screen $screen device $device $d nodes $nodes devname $devname\n";
		}

		if (!defined($last_devid)) {
			$last_devid = $devid;
		}
		if ($last_devid ne $devid) {
			$gpu += 1;
			print "GPU $gpu\n" if $debug > 1;
		}

#		my $monitor = get_monitor($screen, $device, $gpu);
		my $monitor = get_monitor($screen, $device, $scrn);
		print "--- monitor $monitor\n" if $debug > 1;

		printf "%${nwid}s %8s %${screen_width}s    %s  %s\n",
			$nodes, $busid, $display, $devname, $monitor;

		$last_devid = $devid;
		printf "--- last_devid %x\n", $last_devid if $debug > 1;
	}
}

# We need to establish whether we have a topology file before
# calling usage().  See $has_topology.
# Some things can only be done when those details are available.
sub usage
{
	printf "\nversion: %s\n", $version_info;

	print <<EOT ;

USAGE: topology [options]
       gfxtopology [options] # implies --gfx

OPTIONS:
EOT
	if ($has_topology) {
		print <<EOT ;
    primary display options: (with a topology file available)
EOT
	} else {
		print <<EOT ;
    primary display options: (with no topology file available)
EOT
	}
	print <<EOT ;
    -s|--summary    show system summary (default) (1)
    --all           show full system
    --cpus          show cpu info
EOT
	if ($has_topology) {
		print <<EOT ;
    --events        show event info (see events reported below) (Not supported on UV1)
EOT
	}
	print <<EOT ;
    --nodes         show node info (2)
EOT
	if ($has_topology) {
		print <<EOT ;
    --routers       show router info
EOT
	}
	print <<EOT ;
    --io            show all I/O (3)
    --cops          show co-processor info (3)
    --disks         show disk info (3)
    --gfx           show gpu info (3)
    --networks      show network info (3)
    --nvmc          show non-voltile memory controller info (3)

	Adding -v(--verbose) extras:
           (1) show all possible devices and more
           (2) show CPU list and Node Memory list [if PMEM present]
           (3) can add --irqs and --affinity which changes verbosity

    --gpudirect     show GPUs and Infiniband devices sorted by PCI root complex

    -x|--xorg       show only X oriented display
                    (includes monitors which are extracted from the
                     /var/log/Xorg.0.log file.)
    --version       show only version information
                    (useful to verify -h output format)

    operation modifiers:
EOT
	if ($has_topology) {
        print <<EOT ;
    --reset-cache   regenerate lspci cache at $lspci_var_file
EOT
	}
	print <<EOT ;
    --noheaders     do not print column headers or repeat markers
                    (can be used to parse the output - check version for format))
EOT
	if ($has_topology) {
		print <<EOT ;
    --get_systype   return system type as simple string ("UV1", "UV2", etc.)
                    (includes HUB revision if verbose)

    --get_node=<device>  get node associated with device (no other output)
                         (return all local nodes if verbose)
                         types:
                             ":X.Y" implies --gfx device
                             "mic:N" implies --cop device
                             (other devices not yet supported)

    --get_cpus=<device>  similar to --get_node except
                         supplies a cpulist ("cpuJ-cpuK,cpuM-cpuN")
                         returns each cpu if verbose: "cpuJ,cpuJ+1,...,cpuK,..."

    --get_pciids    returns only the PCI domain:bus:slot.func of each device
EOT
	}

	if ($has_topology) {
		print <<EOT ;
    --irqs          show IRQ info (implies --io if no --disks --gfx or --net)
                    (add interrupt count if verbose)
EOT
	} else {
		print <<EOT ;
    --irqs          show IRQ info
                    (add interrupt count if verbose)
EOT
	}
	print <<EOT ;
    --affinity      show smp_affinity for each IRQ (implies --irqs)
                    (also shows local cpu list and adds interrupt count if verbose)
    --nox           do not print X Server Display column (default)
    --show_x	    do print X Server Display column (default for --gfx mode)

    --topo=F        use file F for topology file
    --lspci=F       use file F for PCI input (should have `lspci -m` common format)
EOT
	if ($has_topology) {
		print <<EOT ;
    -N|--notopo     do not use the SGI topology file
EOT
	}
    print <<EOT ;
    --xorgconf=F    use file F instead of /etc/X11/xorg.conf

    -d              increase debug level
    --debug=N       set debug level to N
    -v              increase verbosity of output
    --verbose=N     set verbosity to N

    --check         report unexpected topology findings
    -h|--help       show usage
EOT
	if ($has_topology) {
		print <<EOT ;

    events reported:
    NI Link Re-routes - Reports whether or not any NI links have been re-routed
                        or if any links have hit CRC threshold
EOT
	}
	exit(0);
}

# globals for do_gpudirect
use vars qw(@ofinterest_device $nvidia_vendor $mellanox_vendor $plx_vendor);
use vars qw($intel_vendor @gpunum @gpuname @gpupciid);
use vars qw(@rootcomplex_name @rootcomplex_node @rootcomplex_cpulist);
use vars qw(@rootcomplex_numdevices $current_index);
use vars qw(@file_type @file_name @file_devnum @file_rootcomplexindex @file_pciid);
use vars qw(@file_hcatype @file_level @file_guid @file_portnum @planes @plane_guids);
use vars qw(@file_subnet @file_vendor $INFINIBAND $NVIDIA @plane_ports @plane_devname);

sub
do_gpudirect
{
	$nvidia_vendor = "0x10de";
	$mellanox_vendor = "0x15b3";
	$intel_vendor = "0x8086";
	$plx_vendor = "0x10b5";
	$INFINIBAND = 1; # can be Mellanox Infiniband or Intel OmniPath
	$NVIDIA = 2;
	$current_index = -1;
	
	# save what we know of GPUs from nvidia-smi in @gpunum, @gpuname and @gpupciid
	if (parse_nvidia_smi()) {
		printf("warning: There is no nvidia-smi\n");
	}
	# find all NVIDIA and Infiniband devices (Mellanox or Intel) and save in @ofinterest_device
	walk_pci_devices("/sys/bus/pci/devices", 0);
	# walk the root complexes and accumulate the arrays @rootcomplex_name, @rootcomplex_node,
	# and @rootcomplex_cpulist
	walk_rootcomplexes("/sys/devices", 0, 0, 0, 0);
	sort_plane_guids();
	# print what we have accumulated about the root complexes and devices on them
	print_accumulated();
	exit;
}

sub
parse_nvidia_smi
{
	my ($i, $nvoutput, @lines, @pcs, $line, $r1, $r2, $gpunumber, $gpunm, $gpuid, $num);
	$nvoutput = `nvidia-smi`;
	if (length($nvoutput) == 0) {
		return 1;
	}
	# this is kind of kludgey but perl had trouble with more complex expression
	@lines = split(/\n/, $nvoutput);
	for ($i = 0; $i <= $#lines; $i++) {
		$line = $lines[$i];
		#               |   0  Quadro K2000D     On   | 0000:82:00.0     Off |     N/A |
		@pcs = split(/\|/, $line);
		if ($pcs[1] =~ /\s*?(\d{1,3})(.*$)/ ) {
			$gpunumber = $1;
			$gpunm = $2;
			if (($gpunm =~ /On/) || ($gpunm =~ /Off/)) {
		 		$gpunm =~ s/On//;
		 		$gpunm =~ s/Off//;
				$gpunm =~ s/^\s*//;
				$gpunm =~ s/\s*$//;
				$gpunm =~ s/\.\.\.$//;
				if ($pcs[2] =~ /^\s*(\S*)/ ) {
					$gpuid = $1;
					#  0000:82:00.0
					# but allow the address to be alpha and uppercase
					if ( $gpuid =~ /:\S\S:\d\d\.\d/ ) {
						push @gpunum, $gpunumber;
	 					push @gpuname, $gpunm;
						push @gpupciid, lc($gpuid);
						$num++;
					}
				}
			}
		}
	}
	if (!$num) {
		return 1;
	}
	return 0;
}

# search the file for a NVIDIA vendor id
# and save it as a device of interest
sub
search_vendor
{
        my ($directory, $filename) = @_;
        my ($fullpath, $pcidev, $filecontents);

	$fullpath = "$directory/$filename";
	if (! -f $fullpath) {
		printf ("Error: file %s does not exist<BR>\n", $fullpath);
		return;
	}
	
	$pcidev = $directory;
	$pcidev =~ s/.*\///;
        # above takes up to the last / (it's "greedy")

	$filecontents = get_contents ($fullpath);
	if ($filecontents =~ /$nvidia_vendor/i ) {
		push @ofinterest_device, $pcidev;
	}
}

# search for a vendor the file and return the vendor
sub
get_vendor
{
        my ($directory) = @_;
        my ($fullpath, $pcidev, $filename, $vendor);

	$filename = "vendor";
	$fullpath = "$directory/$filename";
	if (! -f $fullpath) {
		printf ("Error: file %s does not exist<BR>\n", $fullpath);
		return "";
	}
	
	$vendor = get_contents($fullpath);
	return $vendor;
}

# save any device with an 'infiniband' directory as a device of interest
sub
note_infiniband
{
        my ($directory) = @_;
        my ($pcidev);

	$pcidev = $directory;
	$pcidev =~ s/.*\///;
        # above takes up to the last / (it's "greedy")
	push @ofinterest_device, $pcidev;
}

# walk the pci address directories and save all NVIDIA and Infiniband (Mellanox or Intel)
# devices @ofinterest_device
sub
walk_pci_devices {
        my ($dirfull, $level) = @_;
	my ($filefull, $i, @items, @dirs);

	if ((opendir DIR, $dirfull) == 0) {
		printf ("Error opening directory %s: %s\n", $dirfull, $!);
		return;
	}
	@items = readdir DIR;
	closedir DIR;
	for(@items) {
		# don't look in directories . or ..
		if ($_ eq "." || $_ eq ".." ) {
			next;
		}
 		$filefull = "$dirfull/$_";
 		if (-d $filefull) { # directory
			if ($level == 0) {
				# numeric pci address directories only
				if ($_ =~ /^000/) {
					push @dirs, $filefull;
				}
			}
			if ("$_" eq "infiniband" ) {
				note_infiniband($dirfull);
			}
		} elsif (-f $filefull) { # plain file
			if ("$_" eq "vendor" ) {
				search_vendor($dirfull, $_);
			}
 		} elsif (-l $filefull) { # symbolic link
				printf ("Skipping symbolic link %s\n", $filefull);
		} else {
			printf ("Skipping unknown file type %s\n", $filefull);
		}
	}
	for(@dirs) {
		walk_pci_devices($_, $level+1);
	}
}

# walk the root complexes looking for known NVIDIA and Infiniband/Omnipath devices
sub
walk_rootcomplexes {
	my ($dirfull, $do_details, $pcidevice, $current_root_index, $level) = @_;
	my ($filefull, $i, $fnd, @items, $pcidev, $details, $complex_name, $vendor);
	# levels:     0            1            2          3            4           5
	# level 3 pci0000:00/0000:00:02.0/0000:03:00.0/infiniband
	#                      Xeon         omnipath
	# level 5 pci0000:00/0000:00:03.0/0000:04:00.0/0000:05:00.0/0000:06:00.0/vendor
	#                                                 plx          gpu
	# level 5 pci0000:00/0000:00:03.0/0000:04:00.0/0000:05:04.0/0000:07:00.0/infiniband
	#                                   Xeon          plx          plx        omnipath

	if ((opendir DIR, $dirfull) == 0) {
		printf ("Error opening directory %s: %s\n", $dirfull, $!);
		return;
	}
	@items = readdir DIR;
	closedir DIR;

	for (@items) {
		if ($_ eq "." || $_ eq ".." ) {
			next;
		}
 		$filefull = "$dirfull/$_";
 		if (-d $filefull) { # directory
			# e.g.
			# /sys/devices/pci0000:80/0000:80:02.0/0000:82:00.1
			#    level          0          1           2
			if ($level == 0) {
				# pci000... directories only; they are root complexes
				if ($_ =~ /^pci000/) {
					$complex_name = $_;
					$complex_name =~ s/^pci//g;
					push @rootcomplex_name, $complex_name;
					push @rootcomplex_numdevices, 0;
					push @rootcomplex_node, -1;
					push @rootcomplex_cpulist, -1;
					$details = 0;
					$current_index++;
					# walk all the way down a branch before move to the
					# next branch; this keeps current_index valid
					walk_rootcomplexes($filefull, $details, 0,
						$current_index, $level+1);
				}
			} else {
				# 000... directories only
				if ($_ =~ /^000/) {
					# examine the details of the directory only if it
					# is one of our of-interest devices
					$fnd = 0;
					for ($i = 0; $i <= $#ofinterest_device; $i++) {
						if ($ofinterest_device[$i] eq $_ ) {
							$fnd = 1;
							last;
						}
					}
					if ($fnd) {
						# signal the next level to examine files
						# in this directory
						$details = 1;
						$pcidev = $_;
					} else {
						$details = 0;
						$pcidev = 0;
					}
					walk_rootcomplexes($filefull, $details, $pcidev,
						$current_index, $level+1);
				}
				if ($do_details) { # in a directory of a device of interest
					if ("$_" eq "infiniband" ) {
						save_infiniband($dirfull, $pcidevice,
							$current_root_index, $level);
					}
				}
			}
		} elsif (-f $filefull) { # plain file
			if ($do_details) { # in the directory of a device interest
				if ("$_" eq "vendor" ) {
					$vendor = get_contents($filefull);
					chomp($vendor);
					if ($vendor eq $nvidia_vendor) {
						# don't use an NVIDIA device if there is
						# a 'sound' file in this directory; it is
						# not a GPU.
						$fnd = 0;
						for ($i = 0; $i <= $#items; $i++) {
							if ($items[$i] eq "sound") {
								$fnd = 1;
							}
						}
						if (!$fnd) {
							save_nvidia($dirfull, $pcidevice,
								$current_root_index, $level);
						}
					}
				}
			}
		} else {
			printf ("Skipping unexpected file type %s\n", $filefull);
		}
	}
}

# save an Infiniband device in @file_type @file_pciid @file_name @file_devnum
# @file_rootcomplexindex @file_hcatype @file_guid @file_portnum @file_subnet and @file_vendor
# save node and cpulist in the root complex if not already saved
sub
save_infiniband
{
	my ($dirfull, $pcidevice, $root_index, $level) = @_;
	my ($node, $cpulist, @items, $devname, $board, $hca, $guid, $numports);
	my ($subnet, $port, $vendor);

	push @file_type, $INFINIBAND;
	push @file_pciid, $pcidevice;
	push @file_rootcomplexindex, $root_index;
	push @file_devnum, "";
	push @file_level, $level;
	$rootcomplex_numdevices[$root_index]++;
	if ($rootcomplex_node[$root_index] == -1 ) {
		if ( -f "$dirfull/numa_node") {
			$node = get_contents("$dirfull/numa_node");
			chomp($node);
		}
		$rootcomplex_node[$root_index] = $node;
	}
	if ($rootcomplex_cpulist[$root_index] == -1 ) {
		if ( -f "$dirfull/local_cpulist") {
			$cpulist = get_contents("$dirfull/local_cpulist");
			chomp($cpulist);
		}
		$rootcomplex_cpulist[$root_index] = $cpulist;
	}
 	if (-d "$dirfull/infiniband") {
		# infiniband/mlx4_0
		if (opendir(DIR, "$dirfull/infiniband") == 0) {
			printf ("Error opening directory %s: %s\n", "$dirfull/infiniband", $!);
			return;
		}
		@items = readdir DIR;
		closedir DIR;
		for(@items) {
			if ($_ eq "." || $_ eq ".." ) {
				next;
			}
			$devname = $_;
			push @file_name, $devname;
			last;
		}
		$vendor = get_vendor($dirfull);
		push @file_vendor, $vendor;
 		if (-f "$dirfull/infiniband/$devname/hca_type") {
			# infiniband/mlx4_0/mlx4_0/device/hca_type
			$hca = get_contents("$dirfull/infiniband/$devname/hca_type");
			chomp($hca);
		} else {
			$hca = "";
		}
		push @file_hcatype, $hca;

 		if (-d "$dirfull/infiniband/$devname/ports") {
			$numports = count_ports("$dirfull/infiniband/$devname/ports");
			for ($port = 1; $port <= $numports; $port++) {
				if ($port > 1) {
					push @file_type, $INFINIBAND;
					push @file_pciid, $pcidevice;
					push @file_rootcomplexindex, $root_index;
					push @file_devnum, "";
					push @file_level, $level;
					push @file_name, $devname;
					push @file_vendor, $vendor;
					push @file_hcatype, $hca;
				}
				($subnet, $guid) =
					read_port("$dirfull/infiniband/$devname/ports/$port");
				push @file_portnum, $port;
				push @file_subnet, $subnet;
				push @file_guid, $guid;
				save_plane_guid($subnet, $guid, $port, $devname);
			}
		} else {
			push @file_portnum, 0;
			push @file_subnet, 0;
		}
	} else {
		push @file_name, "";
		push @file_hcatype, "";
		push @file_guid, "";
		push @file_vendor, 0;
	}
}

# count the number of numeric entries in this directory
#  /sys/class/infiniband/mlxN_N/ports
sub
count_ports
{
	my ($dirfull) = @_;
	my ($i, @items, $cnt);
	if ((opendir DIR, $dirfull) == 0) {
		printf ("Error opening directory %s: %s\n", $dirfull, $!);
		return 0;
	}
	@items = readdir DIR;
	closedir DIR;
	# for each port:
	for ($i = 0; $i <= $#items; $i++) {
		if ($items[$i] eq "." || $items[$i] eq ".." ) {
			next;
		}
		if ($items[$i] =~ /\d{1,3}/ ) {
			# each port number; there is usually just one:  ports/1/
			$cnt++;
		}
	}
	return $cnt;
}

# get the information about a port from
#  /sys/class/infiniband/mlxN_N/ports/N
sub
read_port
{
	my ($dirfull) = @_;
	my ($i, @items, $cnt, $gids_string, $guid, $subnet_id);
	$gids_string = get_contents("$dirfull/gids/0");
	chomp($gids_string);
	if (length($gids_string) != 39) {
		printf("gids of %s not 39 bytes\n", $gids_string);
		exit(1);
	}
	# return only the values from the first port
	# fec0:0000:0000:0000:7cfe:9003:0040:b7fe
	$subnet_id = substr($gids_string, 0, 19);
	# GUID of the first port
	$guid = substr($gids_string, 20, 19);
	return ($subnet_id, $guid);
}

# save an NVIDIA device in @file_type @file_pciid @file_name @file_devnum @file_hcatype
# @file_rootcomplexindex @file_guid @file_portnum @file_subnet and @file_vendor
# save node and cpulist in the root complex if not already saved
sub
save_nvidia
{
	my ($dirfull, $gpuid, $root_index, $level) = @_;
	my ($i, $node, $cpulist, $fnd);

	$gpuid = lc($gpuid);
	push @file_type, $NVIDIA;
	push @file_level, $level;
	$rootcomplex_numdevices[$root_index]++;
	if ($rootcomplex_node[$root_index] == -1 ) {
		if ( -f "$dirfull/numa_node") {
			$node = get_contents("$dirfull/numa_node");
			chomp($node);
		}
		$rootcomplex_node[$root_index] = $node;
	}
	if ($rootcomplex_cpulist[$root_index] == -1 ) {
		if ( -f "$dirfull/local_cpulist") {
			$cpulist = get_contents("$dirfull/local_cpulist");
			chomp($cpulist);
		}
		$rootcomplex_cpulist[$root_index] = $cpulist;
	}
	$fnd = 0;
	for ($i = 0; $i <= $#gpunum; $i++) {
		if ($gpupciid[$i] eq $gpuid) {
			$fnd = 1;
			push @file_name, $gpuname[$i];
			push @file_pciid, $gpuid;
			push @file_devnum, $gpunum[$i];
			push @file_rootcomplexindex, $root_index;
			last;
		}
	}
	if (!$fnd) {
		push @file_name, "";
		push @file_pciid, $gpuid;
		push @file_devnum, "";
		push @file_rootcomplexindex, $root_index;
	}
	push @file_hcatype, "";
	push @file_guid, "";
	push @file_portnum, 0;
	push @file_subnet, "";
	push @file_vendor, 0;
}

sub
mlxdev_to_netdev
{
	my ($mlxdev) = @_;
	my ($i, @items, $contentsm, $resource);

	if ((opendir DIR, "/sys/class/net") == 0) {
		printf ("Error opening directory %s: %s\n", "/sys/class/net", $!);
		return "";
	}
	@items = readdir DIR;
	closedir DIR;
	# look for a /sys/class/infiniband/mlxN_N/device/resource matching
	# /sys/class/net/$eth/device/resource
	$contentsm = get_contents("/sys/class/infiniband/$mlxdev/device/resource");
	if (!length($contentsm)) {
		printf("Error: cannot read /sys/class/infiniband/$mlxdev/device/resource\n");
		return "";
	}
	for ($i = 0; $i <= $#items; $i++) {
		if ($items[$i] eq "." || $items[$i] eq ".." ) {
			next;
		}
		if ( -f "/sys/class/net/$items[$i]/device/resource") {
			$resource = get_contents("/sys/class/net/$items[$i]/device/resource");
			if (!length($resource)) {
				printf(
				  "Error: cannot read /sys/class/net/$items[$i]/device/resource");
				return "";
			}
			if ($contentsm eq $resource) {
				return $items[$i];
			}
		}
	}
	printf("Error: no ib device found for %s\n", $mlxdev);
	return "";
}

sub
netdev_to_port
{
	my ($netdev) = @_;
	my ($port, $port1);

	$port = get_contents("/sys/class/net/$netdev/dev_port");
	if (!length($port)) {
		printf("Error: cannot read /sys/class/net/$netdev/dev_port");
		return "";
	}
	chomp($port);
	$port1 = get_contents("/sys/class/net/$netdev/dev_id");
	if (!length($port1)) {
		printf("Error: cannot read /sys/class/net/$netdev/dev_id");
		return "";
	}
	chomp($port1);
	if ($port1 > $port) {
		$port = $port1;
	}
	$port++;
	return $port;
}

# called for every infiniband subnet, guid and port we come across; each plane
# is a different fabric; save each unique triplet along with its device name
# (because MPT sorts its ports by device name)
sub
save_plane_guid
{
	my ($plane, $guid, $port, $devname) = @_;
	my ($i, $fnd);

	$fnd = 0;
	for ($i = 0; $i <= $#planes; $i++) {
		if (($plane eq $planes[$i]) && ($guid eq $plane_guids[$i]) &&
		    ($port eq $plane_ports[$i])) {
			$fnd = 1;
			last;
		}
	}
	if (!$fnd) {
		push @planes, $plane;
		push @plane_guids, $guid;
		push @plane_ports, $port;
		push @plane_devname, $devname;
	}
}

# look up a GUID/port in @plane_guids/@plane_ports and @planes and return its plane and port index
sub
lookup_plane_device
{
	my ($guid, $portnum) = @_;
	my ($i, $j, $fnd, $plane_index, $plane_start, $device_index, $subnet);

	$fnd = 0;
	$subnet = $planes[0];
	$plane_index = 0;
	for ($i = 0; $i <= $#planes; $i++) {
		if ($subnet ne $planes[$i]) {
			$plane_index++;
			$subnet = $planes[$i];
			$plane_start = $i;
		}
		if (($guid eq $plane_guids[$i]) && ($portnum == $plane_ports[$i])) {
			$fnd = 1;
			$subnet = $planes[$i];
			$device_index = $i - $plane_start;
			return ($plane_index, $device_index);
			last;
		}
	}
	printf("\nError: guid %s port %d not found in plane_guids\n", $guid, $portnum);
	exit(1);
}

# sort on the whole subnet, the device name and the port
# (MPT sorts by plane (fabric) and sorts by the hca's device name (and port)
sub
sort_plane_guids
{
	my ($i, $j, $holdp, $holdg, $holdd, $holdpo);

	if ($#planes != $#plane_guids) {
		printf("Error: planes and guids are out of sync\n");
		exit(1);
	}
	# selection sort; just push the largest to the top
	for ($i = 0; $i < $#planes; $i++) {
		for ($j = $i + 1; $j <= $#planes; $j++) {
			if (($planes[$i] gt $planes[$j]) ||
				(($planes[$i] eq $planes[$j]) &&
					($plane_devname[$i] gt $plane_devname[$j])) ||
				(($planes[$i] eq $planes[$j]) &&
					($plane_devname[$i] eq $plane_devname[$j]) &&
					($plane_ports[$i] > $plane_ports[$j]))) {
				$holdp = $planes[$i];
				$holdg = $plane_guids[$i];
				$holdd = $plane_devname[$i];
				$holdpo = $plane_ports[$i];
				$planes[$i] = $planes[$j];
				$plane_guids[$i] = $plane_guids[$j];
				$plane_devname[$i] = $plane_devname[$j];
				$plane_ports[$i] = $plane_ports[$j];
				$planes[$j] = $holdp;
				$plane_guids[$j] = $holdg;
				$plane_devname[$j] = $holdd;
				$plane_ports[$j] = $holdpo;
			}
		}
	}
}

# show each root complex that has devices of interest
sub
print_accumulated
{
	my ($i, $j, $mlxdev, $netdev, $port, $connected_to);
	my ($subnet, $mpt_plane, $mpt_device, $last_infiniband);
	for ($i = 0; $i <= $#rootcomplex_name; $i++) {
		if ($rootcomplex_numdevices[$i]) {
			printf("root complex %s numa node %d cpus %s\n",
				$rootcomplex_name[$i], $rootcomplex_node[$i],
				$rootcomplex_cpulist[$i]);
			for ($j = 0; $j <= $#file_pciid ; $j++) {
				if ($file_rootcomplexindex[$j] == $i) {
					if ($file_level[$j] == 3) {
						$connected_to = "cpu   ";
					} elsif ($file_level[$j] == 5) {
						$connected_to = "switch";
					} else {
						printf("warning %s not at level 3 or 5\n",
							$file_pciid[$j]);
					}
					if ($file_type[$j] == $NVIDIA) {
						if (length($file_name[$j])) {
							printf("   GPU:            ");
							printf(
							 "%s connect:%s NVIDIA %s GPU %d\n",
								$file_pciid[$j],
								$connected_to,
								$file_name[$j],
								$file_devnum[$j]);
						} else {
							# without nvidia-smi we have little
							printf("   GPU:            ");
							printf("%s connect:%s NVIDIA GPU\n",
								$file_pciid[$j],
								$connected_to);
						}
					} elsif ($file_type[$j] == $INFINIBAND) {
						if ($file_pciid[$j] eq $last_infiniband) {
						  printf("                                 ");
						  printf("                                 ");
						} else {
						$mlxdev = $file_name[$j];
						printf("   Fabric adapter: ");
						printf("%s connect:%s ",
							$file_pciid[$j], $connected_to);
						if ($file_vendor[$j] eq $mellanox_vendor) {
							printf("Mellanox %s %s",
							$file_hcatype[$j], $file_name[$j]);
						} elsif ($file_vendor[$j] eq $intel_vendor) {
							printf("Intel OmniPath %s ", $mlxdev);
						} else {
							printf("Unknown ");
						}
						$netdev = mlxdev_to_netdev($mlxdev);
						if (length($netdev)) {
							printf(" netdev:%s", $netdev);
						}
						}
						if (($file_portnum[$j])) {
							printf(" port:%d", $file_portnum[$j]);
						}
						if (length($file_subnet[$j])) {
							$subnet = $file_subnet[$j];
							printf(" subnet:%s", $subnet);
						}
						if (length($file_guid[$j])) {
							($mpt_plane, $mpt_device) = 
								lookup_plane_device($file_guid[$j],
									$file_portnum[$j]);
							printf(" MPT[plane %d device %d]",
								$mpt_plane, $mpt_device);
						}
						printf("\n");
						$last_infiniband = $file_pciid[$j];
					}
				}
			}
		}
	}
}

# Print all active footnotes in order of activation
sub
print_footnotes
{
	for my $flag (@active_footnotes) {
		my $footnote = $footnotes[$flag];
		printf("%s %s\n", $footnote->{FOOTNOTE_KEY},
		       "$footnote->{FOOTNOTE_STR}");
	}
}

# Activate a footnote and assign it a footnote key. Append that key to the
# given string. Only call append_footnote_key on strings guaranteed to be
# printed to avoid printing a footnote with no tagged strings.
sub
append_footnote_key
{
	my ($flag, $str) = @_;
	if (!$footnotes_enabled) {
		return $str;
	}
	my $footnote = $footnotes[$flag];
	if (!$footnote->{FOOTNOTE_KEY}) {
		push(@active_footnotes, $flag);
		my $asterix = "*" x scalar(@active_footnotes);
		$footnote->{FOOTNOTE_KEY} = "[$asterix]";
	}
	return "$str $footnote->{FOOTNOTE_KEY}";
}
